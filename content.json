{"meta":{"title":"李晓鹏","subtitle":"Adam","description":"---Talk is cheap. Show me the code.","author":"Adam","url":"http://xpleeandroid.github.io"},"pages":[{"title":"标签","date":"2016-06-26T06:49:10.000Z","updated":"2016-06-28T05:42:00.664Z","comments":true,"path":"tags/index.html","permalink":"http://xpleeandroid.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"PHP学习笔记","slug":"Learn-PHP","date":"2016-07-07T03:33:29.000Z","updated":"2016-07-07T03:34:52.220Z","comments":true,"path":"2016/07/07/Learn-PHP/","link":"","permalink":"http://xpleeandroid.github.io/2016/07/07/Learn-PHP/","excerpt":"","text":"","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://xpleeandroid.github.io/tags/PHP/"}]},{"title":"java8教程-泛型（Generics）","slug":"java8-Generics","date":"2016-06-28T06:04:35.000Z","updated":"2016-06-28T09:48:46.534Z","comments":true,"path":"2016/06/28/java8-Generics/","link":"","permalink":"http://xpleeandroid.github.io/2016/06/28/java8-Generics/","excerpt":"原文链接 [https://docs.oracle.com/javase/tutorial/java/generics/index.html) 翻译： Adamin90 转载请注明出处，谢谢！ 泛型（已更新） 在任何繁琐的（nontrivial）软件项目中，bug是家常便饭。细心的规划，编程和测试可以帮助减少bug的普遍性（pervasiveness）,但是无论如何，无论在哪里，bug总会伺机悄悄溜进（creep）你的代码，因为很明显，新的特性会不断的被引入，并且你的代码基数会不断变大和复杂。 幸运的是，一些bug相比其它比较容易检测。编译时bug可以在早期被检测到；你可以利用编译器的错误信息查明是什么问题并且解决，就在那时。然而，运行时bug会更加未预知,他们不会立即展示出来，不知道什么时候发生，可能根本不在程序真正出现问题的点上。 泛型通过更多的在编译时检测bug为你的代码增加了稳定性。","text":"原文链接 [https://docs.oracle.com/javase/tutorial/java/generics/index.html) 翻译： Adamin90 转载请注明出处，谢谢！ 泛型（已更新） 在任何繁琐的（nontrivial）软件项目中，bug是家常便饭。细心的规划，编程和测试可以帮助减少bug的普遍性（pervasiveness）,但是无论如何，无论在哪里，bug总会伺机悄悄溜进（creep）你的代码，因为很明显，新的特性会不断的被引入，并且你的代码基数会不断变大和复杂。 幸运的是，一些bug相比其它比较容易检测。编译时bug可以在早期被检测到；你可以利用编译器的错误信息查明是什么问题并且解决，就在那时。然而，运行时bug会更加未预知,他们不会立即展示出来，不知道什么时候发生，可能根本不在程序真正出现问题的点上。 泛型通过更多的在编译时检测bug为你的代码增加了稳定性。 为什么要用泛型简言之，泛型能够使类型（类和接口）在定义类，接口和方法的时候参数化。非常像方法定义时用到的形式参数（formal parameters）,类型参数提供了一种你可以通过不同的输入来复用同一段代码的方法。不同点是，形式参数输入的是值，而类型参数输入的是类型。 使用泛型比非泛型有很多好处： 编译时更强大的类型检测 Java编译器对泛型应用了强大的类型检测，如果代码违反了类型安全就会报错。修复编译时错误比修复运行时错误更加容易，因为运行时错误很难查找到。 消除类型转换(Elimination of casts) 以下代码片段没有泛型需要转型： List list = new ArrayList(); list.add(“hello”); String s = (String) list.get(0);当我们重新用泛型编写，代码就不需要类型转换了： List list = new ArrayList(); list.add(“hello”); String s = list.get(0); // no cast 使开发者实现泛型算法 通过泛型，开发者可以自己实现泛型算法，应用到一系列的不同类型，可以自定义，并且类型安全，易读。 泛型类型泛型类型是泛型类或者接口被类型参数化。下面的Box类将被更改演示这个概念。 简单的 Box 类列举一个简单的非泛型 Box操作任意类型的object。它只需要提供两个方法：set，添加一个obejct到box，get,获取这个对象： public class Box { private Object object; public void set(Object object) { this.object = object; } public Object get() { return object; } } 因为它的方法接收或返回一个对象，你可以任意传入，只要传入的不是原始数据类型。我们没有在编译时辨别clas如何使用的。一边可能替换一个 Integer到box，另一边获取的不是Integer类型，而可能传入一个String类型，结果会导致运行时错误。 泛型版本的Box泛型类的定义形式如下： class name&lt;T1, T2, ..., Tn&gt; { /* ... */ } 类型参数部分被一对尖括号（&lt;&gt;）划分，紧跟类名，它指定了类型参数（也叫作类型变量）T1， T2， ….,和Tn. 把原Box类更新为泛型类，你要通过把“public class Box”改变为“public class Box”创建一个类型声明。这会引入一个类型变量, T,你可以在类中任意地方使用。通过这个改变，Box类就变为： /** * Generic version of the Box class. * @param &lt;T&gt; the type of the value being boxed */ public class Box&lt;T&gt; { // T stands for &quot;Type&quot; private T t; public void set(T t) { this.t = t; } public T get() { return t; } } 你可以看到，所有Object出现的地方都被替换为T了。一个类型变量可以指定为任意非原始类型的类型：任意的类，任意的接口，任意的数组，甚至其他的类型变量。同样的技术可以应用到创建泛型接口上。 类型参数命名规则（Naming Conventions）通过规则，类型参数是单独的，大写字母。这个表示鲜明区别了你已知的变量命名规则，一个好的理由是：没有这个规则，你将很难区分类型变量和原生类或接口名的区别。 最普遍使用的类型参数是： E -Element（Java Collections框架大量使用） K -Key N -Number T -Type V -Value S,U,V 等 -第二，第三，第四个类型 你可以在JAVA SE API 看到这些名字的使用。 调用和实例化一个泛型类型要在你的代码引用泛型类 Box，你必须执行 泛型类型调用，把T替换成具体的值，比如Integer： Box&lt;Integer&gt; integerBox; 你可以认为泛型类型调用跟原生方法调用大致一样，但是不是传入一个参数到方法，而是传入一个类型蚕食–这个情况下的Integer–给Box类本身。 Type Parameter和Type Argument术语（Terminology）：很多开发者交换使用这个两个术语，但是这两个术语并不同。敲代码时，type argument 创建一个参数化类型，因此，Foo&lt; T&gt;中的T是type parameter，Foo&lt; String&gt; f中的String是一个type argument。 就想其他的变量定义，上面的代码不会真正创建一个新的 Box对象。它只是声明，integerBox将持有一个“Box of Integer”的引用，用以读取Box.泛型类型的调用通常称为参数化类型。 为了实例化这个类，用new 关键字，把放在类名和括号之间。 Box&lt;Integer&gt; integerBox = new Box&lt;Integer&gt;(); The Diamond在Java SE 7及以后版本，可以省去类型参数调用泛型类的构造函数，用一个空的类型参数（&lt;&gt;）,编译器可以通过上下文决定，或推测type arguments，这个尖括号非正式得叫作diamond(钻石？这么奇葩)，你可以这样创建Box&lt; Integer&gt;的一个实例： Box&lt;Integer&gt; integerBox = new Box&lt;&gt;(); 要查看更多关于diamond 符号和类型推断（inference）,请看类型推断。 多类型参数正如前面提到的，泛型类可以有多个类型参数。比如泛型 OrderedPair 类，实现了泛型接口 Pair： public interface Pair&lt;K, V&gt; { public K getKey(); public V getValue(); } public class OrderedPair&lt;K, V&gt; implements Pair&lt;K, V&gt; { private K key; private V value; public OrderedPair(K key, V value) { this.key = key; this.value = value; } public K getKey() { return key; } public V getValue() { return value; } } 下面的语句创建了两个OrderedPair的实例： Pair&lt;String, Integer&gt; p1 = new OrderedPair&lt;String, Integer&gt;(&quot;Even&quot;, 8); Pair&lt;String, String&gt; p2 = new OrderedPair&lt;String, String&gt;(&quot;hello&quot;, &quot;world&quot;); new OrderedPair把K实例化为String，V实例化为Integer。因此OrderedPair的参数类型分别(respectively)是String和Integer。因为自动装箱，传入String和int到类是有效的。 参数化类型你也可以用一个参数化的类型（ie List&lt; String&gt;）替换（substitute）类型参数（K ，V）,例如用OrderedPair&lt; K,V&gt;: OrderedPair&lt;String, Box&lt;Integer&gt;&gt; p = new OrderedPair&lt;&gt;(&quot;primes&quot;, new Box&lt;Integer&gt;(...));","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://xpleeandroid.github.io/tags/java/"}]},{"title":"翻译:no more findViewById","slug":"translate-no-more-findviewbyid","date":"2016-06-26T06:40:57.000Z","updated":"2016-06-28T09:49:39.814Z","comments":true,"path":"2016/06/26/translate-no-more-findviewbyid/","link":"","permalink":"http://xpleeandroid.github.io/2016/06/26/translate-no-more-findviewbyid/","excerpt":"原文链接 https://medium.com/google-developers/no-more-findviewbyid-457457644885#.cs0jg2og6 翻译： Adamin90 转载请注明出处，谢谢！ No More findViewById Android Studio开发android程序的一个小特点是数据绑定。我会在将来的文章中讲解它的其他一些优雅的特点，但是你要了解的最基础的是怎样消除findViewById.","text":"原文链接 https://medium.com/google-developers/no-more-findviewbyid-457457644885#.cs0jg2og6 翻译： Adamin90 转载请注明出处，谢谢！ No More findViewById Android Studio开发android程序的一个小特点是数据绑定。我会在将来的文章中讲解它的其他一些优雅的特点，但是你要了解的最基础的是怎样消除findViewById.1TextView hello = (TextView) findViewById(R.id.hello); 虽然现在有很多试用的方法可以省略这些多余代码，但是Android Studio 1.5以及更高版本已经有官方的方法了。 首先，你必须在Application的build.gradle里的android块内填写如下代码： android { … dataBinding.enabled = true } 下一步就是在你的layout文件的最外层添加 标签，不管你用的是任何 ViewGroup: &lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt; &lt;RelativeLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot; android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot; android:paddingTop=&quot;@dimen/activity_vertical_margin&quot; android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;TextView android:id=&quot;@+id/hello&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;/&gt; &lt;/RelativeLayout&gt; Layout标签告诉Android Studio这个layout在编译时将进行额外的操作，查找到所有感兴趣的view,并且标签为下一步。所有外部没有包layout标签的布局将不会执行额外操作。所以你可以在新项目中少量使用而无需改变项目中其他的部分。 下面要做的就是告诉它在运行时分别加载你的layout。因为它向后兼容，所以不需要依赖新框架的改变来加载这些预执行的layout文件。因此你只需对程序做一个轻微的改变。 从一个Activity,不是： 123 setContentView(R.layout.hello_world);TextView hello = (TextView) findViewById(R.id.hello);hello.setText(\"Hello World\"); 而是这样加载： HelloWorldBinding binding = DataBindingUtil.setContentView(this, R.layout.hello_world); binding.hello.setText(&quot;Hello World&quot;); 你可以看到 HelloWordBinding这个类自动为hello_world.xml生成并且id为“@+id/hello”的view分配到了一个hello的field你可以使用。没有强制类型转换，没有findViewById. 这标兵这是访问view的机制不仅仅比findViewById更加简单，而且也更加快！绑定程序一次执行覆盖所有layout的view，把view分配到field。当你运行findViewById，的时候view结构每次都会被遍历查找。 你会注意到一件事:它对你的变量名使用了驼峰命名法（比如hello_world.html 变成类 HelloWorldBinding）,所以如果你给它的id是“@+id/hello_text”,那么field的名称将会是 helloText. 当你正在inflate你布局里RecyclerView,ViewPager，或其他不设置Activity内容的控件，你将希望在生成的类上用生成的类型安全的方法，这里有几个版本匹配LayoutInflater,所以使用你最适合食用的.举个例子： HelloWorldBinding binding = HelloWorldBinding.inflate( getLayoutInflater(), container, attachToContainer); 如果你们有把被inflate的view 附加到包含他们的ViewGroup上，你必须访问被infalte的view的view结构。你可以用binding的getRoot()方法： linearLayout.addView(binding.getRoot()); 现在，你可能会考虑，如果我有一个layout包含同步view的不同配置呢？layout预执行和运行时inflate阶段通过添加所有View 的id到生成的类，如果没有被inflate的话设置为null。 相当神奇，不是吗？最好的部分是运行时没有反射和其他任何高消耗的技术。把他少量添加到你现有程序里面非常容易，他能让你的生活更加简单，让你的layout加载的更快！","categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://xpleeandroid.github.io/tags/android/"},{"name":"翻译","slug":"翻译","permalink":"http://xpleeandroid.github.io/tags/翻译/"}]},{"title":"GoodNight","slug":"GoodNight","date":"2016-06-25T15:50:44.000Z","updated":"2016-06-28T05:42:00.662Z","comments":true,"path":"2016/06/25/GoodNight/","link":"","permalink":"http://xpleeandroid.github.io/2016/06/25/GoodNight/","excerpt":"","text":"use one day for establish this blog,thanks for opensource! Now we can say good night! ``","categories":[],"tags":[{"name":"随想","slug":"随想","permalink":"http://xpleeandroid.github.io/tags/随想/"}]}]}