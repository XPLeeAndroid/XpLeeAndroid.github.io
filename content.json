{"meta":{"title":"李晓鹏","subtitle":"Adam","description":"---Talk is cheap. Show me the code.","author":"Adam","url":"http://xpleeandroid.github.io"},"pages":[{"title":"标签","date":"2016-06-26T06:49:10.000Z","updated":"2016-06-28T05:42:00.664Z","comments":true,"path":"tags/index.html","permalink":"http://xpleeandroid.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"CentOS搭建LNMP,搭建ss-panel以及后端经验总结","slug":"centos-build-ss-panel-and-server","date":"2016-10-19T03:32:39.000Z","updated":"2016-10-19T07:53:29.788Z","comments":true,"path":"2016/10/19/centos-build-ss-panel-and-server/","link":"","permalink":"http://xpleeandroid.github.io/2016/10/19/centos-build-ss-panel-and-server/","excerpt":"","text":"前言几个月前开始搭建http://ss.lixiaopeng.top/shadowsocks并免费提供给别人使用，搭建过程中遇到不少问题，在这记录下来。 安装LNMPyum update //更新yum wget -c http://soft.vpser.net/lnmp/lnmp1.3.tar.gz &amp;&amp; tar zxf lnmp1.3.tar.gz &amp;&amp; cd lnmp1.3 &amp;&amp; ./install.sh lnmp 下载并安装lnmp 如果wget过程中出现 -bash: wget: command not found 那么执行 yum -y install wget 安装wget然后继续执行上一步。然后等待lnmp安装完成。 安装ss-panelcd/home/wwwroot/default git clone https://github.com/orvice/ss-panel.git cp -R ss-panel/. ./ cp .env.example .env vi .env 一次填写网站的配置信息，数据库信息 安装composer: curl -sS https://getcomposer.org/installer | php php composer.phar install 把phpmyadmin目录下的内容拷贝到public/phpmyadmin目录下： cp -R phpmyadmin/. public/phpmyadmin/ 添加管理员账号： php xcat createAdmin 添加权限： chmod -R 777 storage 添加www用户访问目录权限： chown -R www /home/wwwroot/default/ cd /usr/local/nginx vi nginx.conf 在 root /home/wwwroot/default后面加 /public 紧跟下面添加： location / { try_files $uri $uri/ /index.php$is_args$args; } 退出vi保存。 service nginx reload 安装shadowsocks manyusermysql -root -p 输入数据库密码;执行use mysql; grant all privileges on *.* to &apos;数据库名&apos;@&apos;manyuser所在ip&apos;identified by &apos;密码&apos; with grant option; 下载rm： git clone -b manyuser https://github.com/mengskysama/shadowsocks-rm.git 安装pip： yum install python-pip -y (Centos7会报错需要这样执行： sudo yum -y install epel-release sudo yum -y install python-pip sudo yum clean all) 安装cymysql： pip install cymysql cd shadowsocks-rm cd shadowsocks vi config.py 填写相应信息保存退出。 python servers.py开启服务。 nohup python servers.py &amp; 后台运行。","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://xpleeandroid.github.io/tags/linux/"},{"name":"vps","slug":"vps","permalink":"http://xpleeandroid.github.io/tags/vps/"},{"name":"ss-panel","slug":"ss-panel","permalink":"http://xpleeandroid.github.io/tags/ss-panel/"},{"name":"shadowsocks","slug":"shadowsocks","permalink":"http://xpleeandroid.github.io/tags/shadowsocks/"}],"keywords":[]},{"title":"中文网站绑定Apache无法解析的问题解决办法","slug":"apache-bind-chinese-domain","date":"2016-10-14T05:40:29.000Z","updated":"2016-10-14T05:52:36.872Z","comments":true,"path":"2016/10/14/apache-bind-chinese-domain/","link":"","permalink":"http://xpleeandroid.github.io/2016/10/14/apache-bind-chinese-domain/","excerpt":"","text":"公司申请了俩网站,www.subanggo.com和www.速帮购.com,服务器上都配好了，今天域名备案成功,于是开始解析，解析中文域名始终不成功，google了一下吗，找到答案了： 中文域名需要先转成punycode,再把punycode绑定到apache的vhost中，关于punycode,维基中解释的很简洁 不在缀余。用在线工具把shop.速帮购.com转成punycode格式:shop.xn–huT195Hu3B.com,然后再绑定到apache： #shop.速帮购 &lt;VirtualHost *:80&gt; DocumentRoot &quot;E:/server/ecmoban/upload&quot; ServerName shop.xn--huT195Hu3B.com:80 ServerAlias ServerAdmin webmaster@shop.xn--huT195Hu3B.com DirectoryIndex index.html index.htm index.php default.php app.php u.php ErrorLog logs/shop.xn--huT195Hu3B.com-error.log CustomLog logs/shop.xn--huT195Hu3B.com-access_%Y%m%d.log comonvhost php_admin_value open_basedir &quot;E:\\server\\ecmoban\\upload\\;E:\\software\\UPUPW_AP5.6-1510\\UPUPW_AP5.6\\htdocs\\;E:\\software\\UPUPW_AP5.6-1510\\UPUPW_AP5.6\\memcached\\;E:\\software\\UPUPW_AP5.6-1510\\UPUPW_AP5.6\\phpmyadmin\\;E:\\software\\UPUPW_AP5.6-1510\\UPUPW_AP5.6\\temp\\;C:\\Windows\\Temp\\&quot; &lt;Directory &quot;E:/server/ecmoban/upload&quot;&gt; Options FollowSymLinks AllowOverride All Require all granted &lt;/Directory&gt; &lt;LocationMatch &quot;/(inc)/(.*)$&quot;&gt; Require all denied &lt;/LocationMatch&gt; &lt;LocationMatch &quot;/(attachment|attachments|uploadfiles|avatar)/(.*).(php|php5|phps|asp|asp.net|jsp)$&quot;&gt; Require all denied &lt;/LocationMatch&gt; &lt;/VirtualHost&gt;","categories":[],"tags":[{"name":"apache","slug":"apache","permalink":"http://xpleeandroid.github.io/tags/apache/"},{"name":"server","slug":"server","permalink":"http://xpleeandroid.github.io/tags/server/"}],"keywords":[]},{"title":"解决CentOS VI中文乱码问题","slug":"centos-vi-chinese-garbled","date":"2016-10-08T05:06:13.000Z","updated":"2016-10-08T05:09:29.932Z","comments":true,"path":"2016/10/08/centos-vi-chinese-garbled/","link":"","permalink":"http://xpleeandroid.github.io/2016/10/08/centos-vi-chinese-garbled/","excerpt":"","text":"centos 7.1 cd /etc/vi virc在最后面增加如下字段: set fileencodings=utf-8,gb2312,gbk,gb18030 set termencoding=utf-8 set fileformats=unix set encoding=prc Over.","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://xpleeandroid.github.io/tags/linux/"}],"keywords":[]},{"title":"Life Record of My 撒欢","slug":"MyGoldRetriever","date":"2016-08-31T05:42:32.000Z","updated":"2016-10-14T04:15:13.043Z","comments":true,"path":"2016/08/31/MyGoldRetriever/","link":"","permalink":"http://xpleeandroid.github.io/2016/08/31/MyGoldRetriever/","excerpt":"2016.08.31大清早的，随地大小便了。","text":"2016.08.31大清早的，随地大小便了。你身后是啥，不要瞪着你无辜的小眼睛看着我！早上下楼听到他在家里叫唤了上班路遇大撒欢三个月的金毛狗狗，三个月后撒欢长啥样？ 2016 0816年8月14日把这货带回家。8.18 8.19 8.20 8.22 2016 099.49.69.159.229.239.249.26 2016 1010.5 10.11 10.13","categories":[],"tags":[{"name":"撒欢","slug":"撒欢","permalink":"http://xpleeandroid.github.io/tags/撒欢/"}],"keywords":[]},{"title":"SS用户说明","slug":"ss-user-guide","date":"2016-08-12T06:54:55.000Z","updated":"2016-10-08T06:48:32.134Z","comments":true,"path":"2016/08/12/ss-user-guide/","link":"","permalink":"http://xpleeandroid.github.io/2016/08/12/ss-user-guide/","excerpt":"","text":"ShadowSocks使用说明shadowsocks是一款开源的基于UDP转发的开源的科学上网工具 客户端下载与配置下载地址: http://download.lixiaopeng.top提供了Windows,Mac OS X ,Android,IOS的客户端以下显示Windows客户端的配置方法 1.下载Windows客户端下载地址 http://download.lixiaopeng.top/ 2.登录”用户中心”并获取配置信息地址 ：http://ss.lixiaopeng.top “server”:”xx.xxx.xxx.xx”, 服务器IP“server_port”:xxx, 服务器端口“local_port”:1080, 本地端口“password”:”xxxx”, 密码“timeout”:600, 这个不用管“method”:”rc4-md5” 加密方式选择一样 3. 双击开客户端软件并配置服务器【一般配置图片里的前4项保存即可】 4. 右击客户端如下图设置代理模式并启用代理 此时即可用浏览器上youtube推特等国外网站","categories":[],"tags":[{"name":"shadowsocks","slug":"shadowsocks","permalink":"http://xpleeandroid.github.io/tags/shadowsocks/"}],"keywords":[]},{"title":"linux日常命令","slug":"daily-linux-command","date":"2016-08-10T03:30:06.000Z","updated":"2016-10-19T06:04:16.205Z","comments":true,"path":"2016/08/10/daily-linux-command/","link":"","permalink":"http://xpleeandroid.github.io/2016/08/10/daily-linux-command/","excerpt":"","text":"ps -aux | grep servers.py 查看servers.py后台进程 -aux 显示所有状态 ps -ef | grep servers.py -e:显示所有进程，环境变量；-f:全格式 -h 不显示标题 kill -9 pid 强制杀死进程pid service iptabes stop 停止防火墙 centos7之前版本 chkconfig iptables off 禁用防火墙 centos7之前版本 systemctl stop firewalld.service 停止防火墙 centos7 systemctl disable firewalld.service 禁用防火墙 centos7 chmod -R 777 shadowsocks-rm mv ss-panel/{.,}* .; rmdir ss-panel 移动ss-panel文件夹下的内容到上级目录，并且删除ss-panel目录 复制目录下所有到另一目录 cp -r phpmyadmin/. public/phpmyadmin/","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://xpleeandroid.github.io/tags/linux/"}],"keywords":[]},{"title":"安卓中使用ThreadPoolExcutor","slug":"using-threadpoolexcuter-in-android","date":"2016-07-29T02:14:02.000Z","updated":"2016-07-29T08:42:00.042Z","comments":true,"path":"2016/07/29/using-threadpoolexcuter-in-android/","link":"","permalink":"http://xpleeandroid.github.io/2016/07/29/using-threadpoolexcuter-in-android/","excerpt":"原文链接 https://medium.freecodecamp.com/threadpoolexecutor-in-android-8e9d22330ee3#.hiw1y4s2e 翻译： Adamin90 转载请注明出处，谢谢！ 这篇文章将涉及到线程池，线程池执行程序，和他们在Android中的使用。我们将使用很多的利用，详细的（thoroughly）介绍这些主题。","text":"原文链接 https://medium.freecodecamp.com/threadpoolexecutor-in-android-8e9d22330ee3#.hiw1y4s2e 翻译： Adamin90 转载请注明出处，谢谢！ 这篇文章将涉及到线程池，线程池执行程序，和他们在Android中的使用。我们将使用很多的利用，详细的（thoroughly）介绍这些主题。 Thread Pools (线程池)一个线程池管理一池的工作线程（准确的数量依赖于它的实现方式）。一个task队列等待池中的空闲线程执行队列中的task.Task被生产者加入队列中，工作线程作为消费者，只要池中有空闲线程在等待新的后台任务，就会从task队列中消费任务。 ThreadPoolExcutorThreadPoolExcutor 从线程池中的一个线程执行一个给定的task。 ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue ); 参数解释： corePoolSize: 线程池中保留线程的最小数目，最开始线程池中没有线程，但是随着task被加入队列，新线程被创建。如果有空闲的线程，但是线程的数目小于corePoolSize，就会创建新的线程。 maximumPoolSize: 线程池中线程的最大值，如果线程数量超过corePoolSize,线程数量&gt;=corePoolSize,那么只有队列满的时候才会创建新的工作线程。 keepAliveTime: 当线程数量超过corepoolsize，非corepoolsize的空闲线程将等待一个新的task，如果在这个定义的时间参数内没有等到新的task，该线程将被终止。 unit： keppAliveTime的时间单位 workQueue: task队列，持有runnable task，必须是一个BlockingQueue. 为什么在Android和JAVA应用程序中使用Thread Pool Executor? 它是一个强大的任务执行框架，支持任务添加到队列，任务取消，任务优先级。 降低了线程创建的开销，它在线程池内管理一定数量的线程。 在Android中使用ThreadPoolExcutor首先，创建一个PriorityThreadFactory: import android.os.Process; import java.util.concurrent.ThreadFactory; /** * Created by Adam on 2016/7/29. */ public class PriorityThreadFactory implements ThreadFactory { private final int mThreadPrority; public PriorityThreadFactory(int mThreadPrority) { this.mThreadPrority = mThreadPrority; } @Override public Thread newThread(final Runnable r) { Runnable runnable = new Runnable() { @Override public void run() { try { Process.setThreadPriority(mThreadPrority); } catch (IllegalArgumentException e) { e.printStackTrace(); } catch (SecurityException e) { e.printStackTrace(); } r.run(); ; } }; return new Thread(runnable); } } 创建一个MainThreadExecutor: import android.os.Handler; import android.os.Looper; import java.util.concurrent.Executor; /** * Created by Adam on 2016/7/29. */ public class MainThreadExecutor implements Executor { private final Handler handler = new Handler(Looper.getMainLooper()); @Override public void execute(Runnable command) { handler.post(command); } } 创建一个DefaultExecutorSupplier: import android.os.Process; import java.util.concurrent.Executor; import java.util.concurrent.LinkedBlockingDeque; import java.util.concurrent.LinkedBlockingQueue; import java.util.concurrent.ThreadFactory; import java.util.concurrent.ThreadPoolExecutor; import java.util.concurrent.TimeUnit; /** * Created by Adam on 2016/7/29. */ public class DefaultExecutorSupplier { /* *指定线程数量 */ public static final int NUMBER_OF_CORES = Runtime.getRuntime().availableProcessors(); /** * 后台任务的线程池 */ private final ThreadPoolExecutor mForBackgroundTasks; /** * 轻量后台任务的线程池 */ private final ThreadPoolExecutor mForLightWeightBackgroundTasks; /** * 主线程任务的线程池executor */ private final Executor mMainThreadExcutor; private static DefaultExecutorSupplier mInstance; /** * 返回DefaultExecutorSupplier的实例 */ public static DefaultExecutorSupplier getInstance() { if (mInstance == null) { synchronized (DefaultExecutorSupplier.class) { mInstance = new DefaultExecutorSupplier(); } } return mInstance; } private DefaultExecutorSupplier() { ThreadFactory backgroundPriorityThreadFactory = new PriorityThreadFactory(Process.THREAD_PRIORITY_BACKGROUND); mForBackgroundTasks = new ThreadPoolExecutor( NUMBER_OF_CORES * 2, NUMBER_OF_CORES * 2, 60L, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), backgroundPriorityThreadFactory ); mForLightWeightBackgroundTasks = new ThreadPoolExecutor( NUMBER_OF_CORES * 2, NUMBER_OF_CORES * 2, 60L, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), backgroundPriorityThreadFactory ); mMainThreadExcutor = new MainThreadExecutor(); } /* * returns the thread pool executor for background task */ public ThreadPoolExecutor forBackgroundTasks() { return mForBackgroundTasks; } /* * returns the thread pool executor for light weight background task */ public ThreadPoolExecutor forLightWeightBackgroundTasks() { return mForLightWeightBackgroundTasks; } /* * returns the thread pool executor for main thread task */ public Executor forMainThreadTasks() { return mMainThreadExcutor; } } 注意：不同线程池的数量依赖于你的需求 现在在你的代码中这样使用 /* * 后台任务 */ public void doSomeBackgroundWork() { DefaultExecutorSupplier.getInstance().forBackgroundTasks() .execute(new Runnable() { @Override public void run() { // 在这里后台工作. } }); } /* * 轻量后台任务 */ public void doSomeLightWeightBackgroundWork() { DefaultExecutorSupplier.getInstance().forLightWeightBackgroundTasks() .execute(new Runnable() { @Override public void run() { // 在这里做一些轻量后台工作. } }); } /* * 主线程任务 */ public void doSomeMainThreadWork() { DefaultExecutorSupplier.getInstance().forMainThreadTasks() .execute(new Runnable() { @Override public void run() { // 做一些中线程工作. } }); } 这样，我们可以为网络任务，I/O任务，重型的后台任务和其他任务创建不同的线程池。 怎样取消一个task？为了取消一个task，你必须得到task的future。所以，不要使用execute，使用submit，将返回一个future。现在future就可以用来取消task了。 Future future= DefaultExecutorSupplier.getInstance().forBackgroundTasks() .submit(new Runnable() { @Override public void run() { } }); future.cancel(true); 如何设置task的优先级？假设队列里有20个任务，线程池持有4个线程，我们根据task的优先级处理他们，因为线程池此时同时可处理4个线程。 但是假设我们需要我们最后推进队列的任务最先执行，我们需要为该任务设置立即的优先当线程从队列里拿取新任务时。 为了设置任务的优先级，我们需要创建一个线程池executor。 为优先级创建一个枚举类: /** * Created by Adam on 2016/7/29. */ public enum Priority { /** * 注意：不要在任何情况下改变顺序，否则会使排序不准确 */ /** * 最低优先级，预加载数据用 */ LOW, /** * 中优先级 */ MEDIUM, /** * 高优先级 */ HIGH, /** * 立即 */ IMMEDIATE, } 创建一个PriorityRunnablepublic class PriorityRunnable implements Runnable { private final Priority priority; public PriorityRunnable(Priority priority) { this.priority = priority; } @Override public void run() { } public Priority getPriority(){ return priority; } } 创建一个PriorityThreadPoolExecutor,继承自ThreadPoolExecutor.我们必须创建PriorityFutureTask,将实现Comparable接口。 import java.util.concurrent.BlockingQueue; import java.util.concurrent.Callable; import java.util.concurrent.Future; import java.util.concurrent.FutureTask; import java.util.concurrent.PriorityBlockingQueue; import java.util.concurrent.ThreadFactory; import java.util.concurrent.ThreadPoolExecutor; import java.util.concurrent.TimeUnit; /** * Created by Adam on 2016/7/29. */ public class PriorityThreadPoolExecutor extends ThreadPoolExecutor { public PriorityThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory) { super(corePoolSize, maximumPoolSize, keepAliveTime, unit, new PriorityBlockingQueue&lt;Runnable&gt;(), threadFactory); } @Override public Future&lt;?&gt; submit(Runnable task) { PriorityFutureTask futureTask = new PriorityFutureTask((PriorityRunnable) task); execute(futureTask); return futureTask; } private static final class PriorityFutureTask extends FutureTask&lt;PriorityRunnable&gt; implements Comparable&lt;PriorityFutureTask&gt; { private final PriorityRunnable priorityRunnable; public PriorityFutureTask(PriorityRunnable priorityRunnable) { super(priorityRunnable, null); this.priorityRunnable = priorityRunnable; } @Override public int compareTo(PriorityFutureTask another) { Priority p1 = priorityRunnable.getPriority(); Priority p2 = another.priorityRunnable.getPriority(); return p2.ordinal() - p1.ordinal(); } } } 首先在DefaultExcutorSupplier,用PriorityThreadPoolExecutor代替ThreadPoolExecutor. ThreadFactory backgroundPriorityThreadFactory = new PriorityThreadFactory(Process.THREAD_PRIORITY_BACKGROUND); // mForBackgroundTasks = new ThreadPoolExecutor( // NUMBER_OF_CORES * 2, // NUMBER_OF_CORES * 2, // 60L, // TimeUnit.SECONDS, // new LinkedBlockingQueue&lt;Runnable&gt;(), // backgroundPriorityThreadFactory // // ); mForBackgroundTasks=new PriorityThreadPoolExecutor( NUMBER_OF_CORES * 2, NUMBER_OF_CORES * 2, 60L, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), backgroundPriorityThreadFactory ); 下面的例子演示了如何设置高优先级： public void doSomeTaskAtHighPriority(){ DefaultExecutorSupplier.getInstance().forBackgroundTasks() .submit(new PriorityRunnable(Priority.HIGH){ @Override public void run() { super.run(); } }); }","categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://xpleeandroid.github.io/tags/android/"},{"name":"翻译","slug":"翻译","permalink":"http://xpleeandroid.github.io/tags/翻译/"}],"keywords":[]},{"title":"安卓计算下载速度","slug":"android-calculate-download-speed","date":"2016-07-28T03:23:13.000Z","updated":"2016-07-28T03:41:16.658Z","comments":true,"path":"2016/07/28/android-calculate-download-speed/","link":"","permalink":"http://xpleeandroid.github.io/2016/07/28/android-calculate-download-speed/","excerpt":"昨天开始封装一个安卓多线程下载器，在写的过程中，猜测想加入检测下载过程中的速度，于是google一番，得出一个比较靠谱的答案，在此总结一下。","text":"昨天开始封装一个安卓多线程下载器，在写的过程中，猜测想加入检测下载过程中的速度，于是google一番，得出一个比较靠谱的答案，在此总结一下。 NANOSECONDSNANOSECONDS，毫微秒，十亿分之一秒，1s=1000000000毫微秒。 CODE EXAMPLE long start = System.nanoTime(); //开始时间 long totalRead = 0; //总共下载了多少 final double NANOS_PER_SECOND = 1000000000.0; //1秒=10亿nanoseconds final double BYTES_PER_MIB = 1024 * 1024; //1M=1024*1024byte while (((len = is.read(buffler, 0, 1024)) &gt;0)) { totalRead += len; double speed = NANOS_PER_SECOND / BYTES_PER_MIB * totalRead / (System.nanoTime() - start + 1); } WARNING这种方法计算的是从start开始时间的平均速度，不是实时速度。","categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://xpleeandroid.github.io/tags/android/"}],"keywords":[]},{"title":"Android拍照上传至PHP服务器并写入MySql数据库(下)","slug":"android-upload-img-to-php-server-2","date":"2016-07-22T07:45:32.000Z","updated":"2016-07-22T08:02:25.418Z","comments":true,"path":"2016/07/22/android-upload-img-to-php-server-2/","link":"","permalink":"http://xpleeandroid.github.io/2016/07/22/android-upload-img-to-php-server-2/","excerpt":"Android实现调用系统相机，拍照： Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); getFileUri(); intent.putExtra(MediaStore.EXTRA_OUTPUT, file_uri); startActivityForResult(intent, CODE_CAMERA); private void getFileUri() { image_name = Calendar.getInstance().getTimeInMillis() + &quot;.jpg&quot;; file = new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES) + File.separator + image_name); file_uri = Uri.fromFile(file); }","text":"Android实现调用系统相机，拍照： Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); getFileUri(); intent.putExtra(MediaStore.EXTRA_OUTPUT, file_uri); startActivityForResult(intent, CODE_CAMERA); private void getFileUri() { image_name = Calendar.getInstance().getTimeInMillis() + &quot;.jpg&quot;; file = new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES) + File.separator + image_name); file_uri = Uri.fromFile(file); } 在onActivityResult里面接收图片并Base64处理： @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { if (requestCode == CODE_CAMERA &amp;&amp; resultCode == RESULT_OK) { new EncodeImage().execute(); //把bitmap转换成base64字符串 } } EncodeImage是一个AsyncTask，doInBackground里面从uri里面获取bitmap，然后转入输出流，最终转换为base64编码字符串： @Override protected Void doInBackground(Void... voids) { bitmap = BitmapFactory.decodeFile(file_uri.getPath()); ByteArrayOutputStream stream = new ByteArrayOutputStream(); bitmap.compress(Bitmap.CompressFormat.JPEG, 80, stream); byte[] array = stream.toByteArray(); encoded_string = Base64.encodeToString(array, 0); bitmap.recycle(); //防止oom return null; } 然后就可以上传到服务器了： private void uploadImage() { HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;encoding_string&quot;, encoded_string); map.put(&quot;image_name&quot;, image_name); OkHttpUtils.post() .url(&quot;http:192.168.0.112/phpdemo/uploadimage.php&quot;) .params(map) .tag(this) .build() .execute(new StringCallback() { @Override public void onError(Call call, Exception e, int id) { Log.e(&quot;出错了&quot;, &quot;错误信息：&quot; + e.getMessage()); } @Override public void onResponse(String response, int id) { Log.e(&quot;成功or失败&quot;, &quot;信息：&quot; + response); } }); } 在上传服务器过程中，遇到两个问题，第一,提示POST Content-Length of ... bytes exceeds the limit of 8388608 bytes,这个错误是因为php默认最大post上传8M,更改php.ini里面的post_max_size=1000M就ok了；第二，当第二次拍照的时候会出现OOM的情况，检查代码发现bitmap没有recycle。 OVER","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://xpleeandroid.github.io/tags/PHP/"},{"name":"Android","slug":"Android","permalink":"http://xpleeandroid.github.io/tags/Android/"}],"keywords":[]},{"title":"Android拍照上传至PHP服务器并写入MySql数据库(上)","slug":"android-upload-img-to-php-server-1","date":"2016-07-21T08:45:00.000Z","updated":"2016-07-22T07:47:25.904Z","comments":true,"path":"2016/07/21/android-upload-img-to-php-server-1/","link":"","permalink":"http://xpleeandroid.github.io/2016/07/21/android-upload-img-to-php-server-1/","excerpt":"需求分析需求很简单，Android客户端点击拍照后，进行Base64加密，自动上传至服务器，服务器接收上传的数据并解密后保存到指定文件夹下，并将图片信心写入数据库，并返回相应的Json数据。","text":"需求分析需求很简单，Android客户端点击拍照后，进行Base64加密，自动上传至服务器，服务器接收上传的数据并解密后保存到指定文件夹下，并将图片信心写入数据库，并返回相应的Json数据。 数据库创建数据库数据库名称为 turtorial_upload_image: CREATE DATABASE tutorial_upload_image; 创建表我们要保存的信息是图片的名称和图片的路径，表名称是photos： CREATE TABLE photos( id INT(32) NOT NULL AUTO_INCREMENT, name VARCHAR(30) NOT NULL, path VARCHAR(30) NOT NULL, PRIMARY KEY(id) ); PHP先上代码： &lt;?php /** * Created by PhpStorm. * User: Adam * Date: 2016/7/21 * Time: 15:01 */ header(&apos;Content-type ： bitmap; charset=utf-8;&apos;); $dbms = &apos;mysql&apos;; //数据库类型 $host = &apos;localhost&apos;; //数据库主机名 $dbName = &apos;tutorial_upload_image&apos;; //使用的数据库 $user = &apos;root&apos;; //数据库连接用户名 $pass = &apos;&apos;; //对应的密码 $dsn = &quot;$dbms:host=$host;dbname=$dbName&quot;; if (isset($_POST[&quot;encoding_string&quot;])) { $encoding_string = $_POST[&quot;encoding_string&quot;]; $image_name = $_POST[&quot;image_name&quot;]; //decode 客户端上传的base64数据 $decoded_string = base64_decode($encoding_string); $path = &quot;images/&quot; . $image_name; //定义存放路径 $file = fopen($path, &quot;wb&quot;); $is_written = fwrite($file, $decoded_string); fclose($file); //写入数据库 if ($is_written &gt; 0) { //sql语句 $strSql = &quot;insert into photos(name,path) values(&apos;$image_name&apos;,&apos;$path&apos;)&quot;; //方法一 pdo方式 支持多种数据库 try { $dbh = new PDO($dsn, $user, $pass); //初始化一个PDO对象 $temp = $dbh-&gt;prepare($strSql); $temp-&gt;execute(); $array = array( &quot;status&quot; =&gt; true, &quot;msg&quot; =&gt; &quot;插入数据成功&quot; ); echo json_encode($array); $dbh = null; //运行完成后关闭链接 } catch (PDOException $e) { $array = array( &quot;status&quot; =&gt; false, &quot;msg&quot; =&gt; &quot;插入数据失败&quot; . ($e-&gt;getMessage()) ); echo json_encode($array); } //方法2 mysqli方式 // $connection=mysqli_connect(&apos;localhost&apos;,&apos;root&apos;,&apos;&apos;,&apos;tutorial_upload_image&apos;); // $result=mysqli_query($connection,$strSql); // if($result){ // $array = array ( // &quot;status&quot; =&gt; true, // &quot;msg&quot; =&gt; &quot;插入数据成功&quot; // ); // echo json_encode($array); // }else{ // $array = array ( // &quot;status&quot; =&gt; false, // &quot;msg&quot; =&gt; &quot;插入数据失败&quot; // ); // echo json_encode($array); // } // mysqli_close($connection); //关闭连接 } } ?&gt; 这里我列举了两种连接数据库的方式 PDO和mysqli ，mysql方式官方已经不推荐使用了，所以就不再列举（我也没用过）。数据库连接过程首先是读取POST过来的内容，然后写到images目录下面，再把地址和名称写入数据库里，返回相应的JSON数据，在这里每次上传完毕后都关闭了连接。 测试测试阶段我们找用postman进行模拟发送数据，首先在这个网站Base64 encode一张图片，复制之后，拷贝到postman里面，postman数据如下： 测试结果成功~ 下节我们将开发安卓客户端。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://xpleeandroid.github.io/tags/PHP/"},{"name":"Android","slug":"Android","permalink":"http://xpleeandroid.github.io/tags/Android/"}],"keywords":[]},{"title":"anonymous","slug":"newsapi","date":"2016-07-20T08:12:35.000Z","updated":"2016-07-20T08:16:24.973Z","comments":true,"path":"2016/07/20/newsapi/","link":"","permalink":"http://xpleeandroid.github.io/2016/07/20/newsapi/","excerpt":"register(host club.qingdaonews.com)","text":"register(host club.qingdaonews.com) step1 /user/touch_reg.php param: act=regstep1&amp;reg_un=adamin90&amp;reg_pw=wsxqaz123&amp;con_pw=wsxqaz123&amp;tel=15725266012 error response :{“result”:”error”,”type”:”tel”,”info”:”\\u6b64\\u624b\\u673a\\u53f7\\u5df2\\u7ecf\\u6ce8\\u518c(\\u9ad8)”} success response :{“result”:”success”,”type”:”code”,”info”:”\\u53d1\\u9001\\u6210\\u529f”} login (host app.qingdaonews.com) /shoujikehuduan/interface_login.php?username=15725266012&amp;password=wsxqaz success response :{“result”:”success”,”point”:”200”,”uid”:”8087267”,”phone”:”15725266012”,”first”:0,”token”:”52165771559e88f430573c6cd0925e68”,”money”:”0”,”face”:”http:\\/\\/pic.qingdaonews.com\\/f\\/avatar_big.jpg”,”type”:”passport”,”username”:”15725266012”,”loginname”:”15725266012”,”password”:”wsxqaz”} error response :{“result”:”error”,”point”:null,”uid”:””,”phone”:null,”first”:0,”face”:”http:\\/\\/pic.qingdaonews.com\\/f\\/avatar_big.jpg”,”type”:”passport”,”username”:”15725266019”,”loginname”:”15725266019”,”password”:”123456”} 签到 post app.qingdaonews.com/shoujikehuduan/interface_missionstate.php?token=52165771559e88f430573c6cd0925e68&amp;mission=mis_10 头条/shoujikehuduan/mdi_newslist300.php?v=2.0&amp;num=20&amp;type=bd /shoujikehuduan/mdi_newslist300.php?v=2.0&amp;num=20&amp;type=bd&amp;minid=463459 青青岛/imobile/index.php?page=1&amp;title=%E5%A4%B4%E6%9D%A1&amp;type=newsapp 焦点/shoujikehuduan/mdi_newslist300.php?v=2.0&amp;num=20&amp;type=jdxw /shoujikehuduan/mdi_newslist300.php?v=2.0&amp;num=20&amp;type=jdxw&amp;minid=462981 体育/shoujikehuduan/mdi_newslist300.php?v=2.0&amp;num=20&amp;type=ty 文娱yl 房产qdfc 汽车qdqc 旅游qdly 家居qdjj 财经cj 教育jy 健康jk 消费xf 舆情yuqing 婚假hj 民生msbl 黄岛 huangdao","categories":[],"tags":[{"name":"api","slug":"api","permalink":"http://xpleeandroid.github.io/tags/api/"}],"keywords":[]},{"title":"English Jokes（英文笑话）","slug":"English-Jokes","date":"2016-07-07T06:43:44.000Z","updated":"2016-07-07T07:04:33.191Z","comments":true,"path":"2016/07/07/English-Jokes/","link":"","permalink":"http://xpleeandroid.github.io/2016/07/07/English-Jokes/","excerpt":"1. 十个大兵与两个小偷的故事Ten soldiers were setting up tents in the forest preparing for the night. Later, two thieves arrived and attempted to rob them of their rations, but were caught. The soldiers told them, &quot;We would kill you, but we&apos;re in a good mood today. We&apos;ll release you if you can make us all laugh.&quot; The thieves reluctantly agreed. One begins to tell a humorous story. After the story, nine of the soldiers are laughing hysterically. However, one is merely looking at the thief with a blank stare. Consequently, one soldier told the thief &quot;Sorry, not all of us laughed,&quot; and killed him. The other thief was nervous after seeing his friend killed, so he told a much less entertaining story. No soldiers were laughing except for the one who didn&apos;t laugh previously, so they killed the second thief as well. After killing the thieves, the soldiers asked their friend, &quot;Why did you laugh during the second thief&apos;s story but not during the first&apos;s? It was much funnier after all.&quot; He responded, &quot;When the second thief was speaking, I finally understood the first thief&apos;s story, and it was damn funny.&quot; 引用Zootopia（疯狂动物城）的一个场景，so hilarious!：","text":"1. 十个大兵与两个小偷的故事Ten soldiers were setting up tents in the forest preparing for the night. Later, two thieves arrived and attempted to rob them of their rations, but were caught. The soldiers told them, &quot;We would kill you, but we&apos;re in a good mood today. We&apos;ll release you if you can make us all laugh.&quot; The thieves reluctantly agreed. One begins to tell a humorous story. After the story, nine of the soldiers are laughing hysterically. However, one is merely looking at the thief with a blank stare. Consequently, one soldier told the thief &quot;Sorry, not all of us laughed,&quot; and killed him. The other thief was nervous after seeing his friend killed, so he told a much less entertaining story. No soldiers were laughing except for the one who didn&apos;t laugh previously, so they killed the second thief as well. After killing the thieves, the soldiers asked their friend, &quot;Why did you laugh during the second thief&apos;s story but not during the first&apos;s? It was much funnier after all.&quot; He responded, &quot;When the second thief was speaking, I finally understood the first thief&apos;s story, and it was damn funny.&quot; 引用Zootopia（疯狂动物城）的一个场景，so hilarious!： 2. 狮子和森林动物的故事（给乌龟跪了）One day a lion wakes up in a bad mood and summons the other animals in the jungle. &quot;I want each of you to tell a joke, but I warn you that if anyone of you fails to laugh, I&apos;ll kill the one who told it. Let&apos;s see, monkey, you will be first.&quot; Shaking with fear the monkey begins, &quot;Two men are in the street and...&quot; When he finishes, everyone bursts out laughing save the tortoise. &quot;The tortoise didn&apos;t laugh!&quot; roars the lion, pouncing on the monkey and ripping him to pieces. Then he orders, &quot;Elephant, you&apos;re next.&quot; Cursing through clenched teeth, the elephant begins, &quot;A drunk walks into a bar and...&quot; When he finishes, all the animals split their sides laughing except the tortoise, who remains impassive. &quot;The tortoise didn&apos;t think it was funny!&quot; exclaimed the lion who, seeing that the furious elephant is about to step on the tortoise, kills the elephant with his claws. By now, everyone wants to murder the tortoise, but nobody dares move. &quot;Now it&apos;s your turn, tiger,&quot; orders the lion. The scared tiger begins, &quot;They say that Little Red Riding Hood...&quot; At that moment, the tortoise falls over laughing. &quot;What&apos;s with you?&quot; bellows the lion. &quot;Tiger hasn&apos;t finished yet...&quot; To which the tortoise replies, &quot;The monkey&apos;s joke is hilarious!&quot; 3. 王后跟三个犯人的故事（the queen will get watermelon shoved up the third prisoner’s ass? hahaha!）Three prisoners on death row are summoned by the queen for a chance to be free. The queen tells the prisoners they have one day to go into the jungle and bring her a fruit. If she likes it, they are free to go. However, if she doesn&apos;t like it, the fruit of their will be shoved up their ass, and then killed they will be back on death row. The first one comes back with grapes. The queen does not like the grapes and while the grapes were being shoved up his ass, the prisoner was crying. The second prisoner returns with an apple. Again, the queen does not like the apple and the apple gets shoved up the second prisoner&apos;s ass. However, the first prisoner noticed that he was laughing while the apple was being inserted. When asked why he was crying, the second prisoner said &quot;I saw the third prisoner coming back with a watermelon.&quot;","categories":[],"tags":[{"name":"娱乐","slug":"娱乐","permalink":"http://xpleeandroid.github.io/tags/娱乐/"}],"keywords":[]},{"title":"PHP学习笔记","slug":"Learn-PHP","date":"2016-07-07T03:33:29.000Z","updated":"2016-07-08T09:51:53.028Z","comments":true,"path":"2016/07/07/Learn-PHP/","link":"","permalink":"http://xpleeandroid.github.io/2016/07/07/Learn-PHP/","excerpt":"","text":"php文件操作的模式 r 只读权限打开文件 w 只写权限打开文件，擦除内容，如果没有则新建文件 a 只写权限打开文件 x 新建一个只写权限的文件 r+ 打开读/写权限文件 w+ 打开读/写权限的文件， 擦除内容，如果没有则新建文件 a+ 打开读/写权限文件，如果没有则新建文件； x+ 新建一个读/写权限的文件 将表单提交到本身页面只需将form的action 设置为&lt;?php echo $_SERVER[&#39;PHP_SELF&#39;];?&gt;为了防止跨站点攻击(XSS)，我们通常需要使用htmlspecialchars()避免$_SERVER[“PHP_SELF”] 被利用。如下： &lt;form method=&quot;post&quot; action=&quot;&lt;?php echo htmlspecialchars($_SERVER[&quot;PHP_SELF&quot;]);?&gt;&quot;&gt; 正则匹配规则 [abc] 单独的字符串 ：a,b或c [^abc] 任意的单独字符串单不是a,b,或c [a-z] a-z任意的单独字符串 [a-zA-Z] a-z 或A-Z中任意的单独字符串 ^ 匹配整行开头 (比如 ^\\d+匹配的是任意的数字开头的字符串) $ 匹配整行结尾 (比如\\d+$匹配任意以数字结尾的字符串) \\A 匹配字符串输入的开头 \\z 匹配字符串输入的结尾 . 任意单个字符串 \\s 任意空字符串 \\S 任意非空字符串 \\d 任意数字 \\D 任意非数字 \\w 任意任何单字符（数字，字母，下滑线）、 \\W 任意非字符 \\B 匹配任意链接字符串 （…） 捕获封闭的内容 (a|b) 匹配a或b a? 0或1个a a* 0或多个a a+ 1或多个a a{3} 三个a a{3,} 3个或更多a a{3,6} 3到6个a i 忽略大小写 m 匹配多行 x 忽略空白","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://xpleeandroid.github.io/tags/PHP/"}],"keywords":[]},{"title":"java8教程-泛型（Generics）","slug":"java8-Generics","date":"2016-06-28T06:04:35.000Z","updated":"2016-07-20T09:34:13.862Z","comments":true,"path":"2016/06/28/java8-Generics/","link":"","permalink":"http://xpleeandroid.github.io/2016/06/28/java8-Generics/","excerpt":"原文链接 [https://docs.oracle.com/javase/tutorial/java/generics/index.html) 翻译： Adamin90 转载请注明出处，谢谢！ 泛型（已更新） 在任何繁琐的（nontrivial）软件项目中，bug是家常便饭。细心的规划，编程和测试可以帮助减少bug的普遍性（pervasiveness）,但是无论如何，无论在哪里，bug总会伺机悄悄溜进（creep）你的代码，因为很明显，新的特性会不断的被引入，并且你的代码基数会不断变大和复杂。 幸运的是，一些bug相比其它比较容易检测。编译时bug可以在早期被检测到；你可以利用编译器的错误信息查明是什么问题并且解决，就在那时。然而，运行时bug会更加未预知,他们不会立即展示出来，不知道什么时候发生，可能根本不在程序真正出现问题的点上。 泛型通过更多的在编译时检测bug为你的代码增加了稳定性。","text":"原文链接 [https://docs.oracle.com/javase/tutorial/java/generics/index.html) 翻译： Adamin90 转载请注明出处，谢谢！ 泛型（已更新） 在任何繁琐的（nontrivial）软件项目中，bug是家常便饭。细心的规划，编程和测试可以帮助减少bug的普遍性（pervasiveness）,但是无论如何，无论在哪里，bug总会伺机悄悄溜进（creep）你的代码，因为很明显，新的特性会不断的被引入，并且你的代码基数会不断变大和复杂。 幸运的是，一些bug相比其它比较容易检测。编译时bug可以在早期被检测到；你可以利用编译器的错误信息查明是什么问题并且解决，就在那时。然而，运行时bug会更加未预知,他们不会立即展示出来，不知道什么时候发生，可能根本不在程序真正出现问题的点上。 泛型通过更多的在编译时检测bug为你的代码增加了稳定性。 为什么要用泛型简言之，泛型能够使类型（类和接口）在定义类，接口和方法的时候参数化。非常像方法定义时用到的形式参数（formal parameters）,类型参数提供了一种你可以通过不同的输入来复用同一段代码的方法。不同点是，形式参数输入的是值，而类型参数输入的是类型。 使用泛型比非泛型有很多好处： 编译时更强大的类型检测 Java编译器对泛型应用了强大的类型检测，如果代码违反了类型安全就会报错。修复编译时错误比修复运行时错误更加容易，因为运行时错误很难查找到。 消除类型转换(Elimination of casts) 以下代码片段没有泛型需要转型： List list = new ArrayList(); list.add(“hello”); String s = (String) list.get(0);当我们重新用泛型编写，代码就不需要类型转换了： List list = new ArrayList(); list.add(“hello”); String s = list.get(0); // no cast 使开发者实现泛型算法 通过泛型，开发者可以自己实现泛型算法，应用到一系列的不同类型，可以自定义，并且类型安全，易读。 泛型类型泛型类型是泛型类或者接口被类型参数化。下面的Box类将被更改演示这个概念。 简单的 Box 类列举一个简单的非泛型 Box操作任意类型的object。它只需要提供两个方法：set，添加一个obejct到box，get,获取这个对象： public class Box { private Object object; public void set(Object object) { this.object = object; } public Object get() { return object; } } 因为它的方法接收或返回一个对象，你可以任意传入，只要传入的不是原始数据类型。我们没有在编译时辨别clas如何使用的。一边可能替换一个 Integer到box，另一边获取的不是Integer类型，而可能传入一个String类型，结果会导致运行时错误。 泛型版本的Box泛型类的定义形式如下： class name&lt;T1, T2, ..., Tn&gt; { /* ... */ } 类型参数部分被一对尖括号（&lt;&gt;）划分，紧跟类名，它指定了类型参数（也叫作类型变量）T1， T2， ….,和Tn. 把原Box类更新为泛型类，你要通过把“public class Box”改变为“public class Box”创建一个类型声明。这会引入一个类型变量, T,你可以在类中任意地方使用。通过这个改变，Box类就变为： /** * Generic version of the Box class. * @param &lt;T&gt; the type of the value being boxed */ public class Box&lt;T&gt; { // T stands for &quot;Type&quot; private T t; public void set(T t) { this.t = t; } public T get() { return t; } } 你可以看到，所有Object出现的地方都被替换为T了。一个类型变量可以指定为任意非原始类型的类型：任意的类，任意的接口，任意的数组，甚至其他的类型变量。同样的技术可以应用到创建泛型接口上。 类型参数命名规则（Naming Conventions）通过规则，类型参数是单独的，大写字母。这个表示鲜明区别了你已知的变量命名规则，一个好的理由是：没有这个规则，你将很难区分类型变量和原生类或接口名的区别。 最普遍使用的类型参数是： E -Element（Java Collections框架大量使用） K -Key N -Number T -Type V -Value S,U,V 等 -第二，第三，第四个类型 你可以在JAVA SE API 看到这些名字的使用。 调用和实例化一个泛型类型要在你的代码引用泛型类 Box，你必须执行 泛型类型调用，把T替换成具体的值，比如Integer： Box&lt;Integer&gt; integerBox; 你可以认为泛型类型调用跟原生方法调用大致一样，但是不是传入一个参数到方法，而是传入一个类型蚕食–这个情况下的Integer–给Box类本身。 Type Parameter和Type Argument术语（Terminology）：很多开发者交换使用这个两个术语，但是这两个术语并不同。敲代码时，type argument 创建一个参数化类型，因此，Foo&lt; T&gt;中的T是type parameter，Foo&lt; String&gt; f中的String是一个type argument。 就想其他的变量定义，上面的代码不会真正创建一个新的 Box对象。它只是声明，integerBox将持有一个“Box of Integer”的引用，用以读取Box.泛型类型的调用通常称为参数化类型。 为了实例化这个类，用new 关键字，把放在类名和括号之间。 Box&lt;Integer&gt; integerBox = new Box&lt;Integer&gt;(); The Diamond在Java SE 7及以后版本，可以省去类型参数调用泛型类的构造函数，用一个空的类型参数（&lt;&gt;）,编译器可以通过上下文决定，或推测type arguments，这个尖括号非正式得叫作diamond(钻石？这么奇葩)，你可以这样创建Box&lt; Integer&gt;的一个实例： Box&lt;Integer&gt; integerBox = new Box&lt;&gt;(); 要查看更多关于diamond 符号和类型推断（inference）,请看类型推断。 多类型参数正如前面提到的，泛型类可以有多个类型参数。比如泛型 OrderedPair 类，实现了泛型接口 Pair： public interface Pair&lt;K, V&gt; { public K getKey(); public V getValue(); } public class OrderedPair&lt;K, V&gt; implements Pair&lt;K, V&gt; { private K key; private V value; public OrderedPair(K key, V value) { this.key = key; this.value = value; } public K getKey() { return key; } public V getValue() { return value; } } 下面的语句创建了两个OrderedPair的实例： Pair&lt;String, Integer&gt; p1 = new OrderedPair&lt;String, Integer&gt;(&quot;Even&quot;, 8); Pair&lt;String, String&gt; p2 = new OrderedPair&lt;String, String&gt;(&quot;hello&quot;, &quot;world&quot;); new OrderedPair把K实例化为String，V实例化为Integer。因此OrderedPair的参数类型分别(respectively)是String和Integer。因为自动装箱，传入String和int到类是有效的。 参数化类型你也可以用一个参数化的类型（ie List&lt; String&gt;）替换（substitute）类型参数（K ，V）,例如用OrderedPair&lt; K,V&gt;: OrderedPair&lt;String, Box&lt;Integer&gt;&gt; p = new OrderedPair&lt;&gt;(&quot;primes&quot;, new Box&lt;Integer&gt;(...)); 原类型（Raw Types）原类型是指泛型类或泛型接口的名字没有任何参数，比如，给出泛型类Box： public class Box(T){ public void set(T t){ /* ...... */ } } 你可以为形参T赋值一个真实的类型参数来创建一个参数化类型的 Box（T）： Box(Ingeter) intBox=new Box&lt;&gt;(); 如果真实的类型参数被省略掉了，你就创建了一个原类型的Box: Box rawBox =new Box(); 因此，Box是Box的原类型。然而，非泛型类或非泛型接口没有原类型。原类型出现在遗赠的代码里是因为大量的API类（比如Collections类）在JDK5之前不是泛型类。当使用原类型的时候，你本质上使用的是泛型之前的表现—Box -&gt;Object.为了向后兼容，赋值参数化类型给他的原类型是允许的： Box&lt;String&gt; stringBox=new Box&lt;&gt;(); Box rawBox=stringBox; //OK 但是如果你赋值一个原类型给一个参数化的类型，你将得到警告： Box rawBox=new Box(); //rawBox是Box&lt;T&gt;()的原类型 Box&lt;Integer&gt; intBox=rawBox; //warning:unchecked conversion 当你用原类型调用关联的反省类型的泛型方法时，你也会得到警告： Box&lt;String&gt; stringBox=new Box&lt;&gt;(); Box rawBox=stringBox; rawBox.set(8); //waring: unchecked invocation to set(T) 警告显示原类型绕过泛型类型检查，延迟捕获不安全代码到运行时。因此，你需要避免使用原类型。类型擦除部分会有更多关于Java编译器如何使用原类型的内容。 Unchecked Error Messages正如上面提到的，当混合遗赠代码和泛型代码时，你可能会碰到跟下面相似的警告： Note: Example.java uses unchecked or unsafe operations. Note: Recompile with -Xlint:unchecked for details. 这发生在当使用老的API操作原类型时，例如如下代码： public class WarningDemo { Box&lt;Integer&gt; bi; bi=createBox(); } static Box createBox(){ return new Box(); } ‘unchecked’指的是编译器没有足够的类型信息来执行所有必要的类型检查以保证类型安全。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://xpleeandroid.github.io/tags/java/"}],"keywords":[]},{"title":"翻译:no more findViewById","slug":"translate-no-more-findviewbyid","date":"2016-06-26T06:40:57.000Z","updated":"2016-06-28T09:49:39.814Z","comments":true,"path":"2016/06/26/translate-no-more-findviewbyid/","link":"","permalink":"http://xpleeandroid.github.io/2016/06/26/translate-no-more-findviewbyid/","excerpt":"原文链接 https://medium.com/google-developers/no-more-findviewbyid-457457644885#.cs0jg2og6 翻译： Adamin90 转载请注明出处，谢谢！ No More findViewById Android Studio开发android程序的一个小特点是数据绑定。我会在将来的文章中讲解它的其他一些优雅的特点，但是你要了解的最基础的是怎样消除findViewById.","text":"原文链接 https://medium.com/google-developers/no-more-findviewbyid-457457644885#.cs0jg2og6 翻译： Adamin90 转载请注明出处，谢谢！ No More findViewById Android Studio开发android程序的一个小特点是数据绑定。我会在将来的文章中讲解它的其他一些优雅的特点，但是你要了解的最基础的是怎样消除findViewById.1TextView hello = (TextView) findViewById(R.id.hello); 虽然现在有很多试用的方法可以省略这些多余代码，但是Android Studio 1.5以及更高版本已经有官方的方法了。 首先，你必须在Application的build.gradle里的android块内填写如下代码： android { … dataBinding.enabled = true } 下一步就是在你的layout文件的最外层添加 标签，不管你用的是任何 ViewGroup: &lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt; &lt;RelativeLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot; android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot; android:paddingTop=&quot;@dimen/activity_vertical_margin&quot; android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;TextView android:id=&quot;@+id/hello&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;/&gt; &lt;/RelativeLayout&gt; Layout标签告诉Android Studio这个layout在编译时将进行额外的操作，查找到所有感兴趣的view,并且标签为下一步。所有外部没有包layout标签的布局将不会执行额外操作。所以你可以在新项目中少量使用而无需改变项目中其他的部分。 下面要做的就是告诉它在运行时分别加载你的layout。因为它向后兼容，所以不需要依赖新框架的改变来加载这些预执行的layout文件。因此你只需对程序做一个轻微的改变。 从一个Activity,不是： 123 setContentView(R.layout.hello_world);TextView hello = (TextView) findViewById(R.id.hello);hello.setText(\"Hello World\"); 而是这样加载： HelloWorldBinding binding = DataBindingUtil.setContentView(this, R.layout.hello_world); binding.hello.setText(&quot;Hello World&quot;); 你可以看到 HelloWordBinding这个类自动为hello_world.xml生成并且id为“@+id/hello”的view分配到了一个hello的field你可以使用。没有强制类型转换，没有findViewById. 这标兵这是访问view的机制不仅仅比findViewById更加简单，而且也更加快！绑定程序一次执行覆盖所有layout的view，把view分配到field。当你运行findViewById，的时候view结构每次都会被遍历查找。 你会注意到一件事:它对你的变量名使用了驼峰命名法（比如hello_world.html 变成类 HelloWorldBinding）,所以如果你给它的id是“@+id/hello_text”,那么field的名称将会是 helloText. 当你正在inflate你布局里RecyclerView,ViewPager，或其他不设置Activity内容的控件，你将希望在生成的类上用生成的类型安全的方法，这里有几个版本匹配LayoutInflater,所以使用你最适合食用的.举个例子： HelloWorldBinding binding = HelloWorldBinding.inflate( getLayoutInflater(), container, attachToContainer); 如果你们有把被inflate的view 附加到包含他们的ViewGroup上，你必须访问被infalte的view的view结构。你可以用binding的getRoot()方法： linearLayout.addView(binding.getRoot()); 现在，你可能会考虑，如果我有一个layout包含同步view的不同配置呢？layout预执行和运行时inflate阶段通过添加所有View 的id到生成的类，如果没有被inflate的话设置为null。 相当神奇，不是吗？最好的部分是运行时没有反射和其他任何高消耗的技术。把他少量添加到你现有程序里面非常容易，他能让你的生活更加简单，让你的layout加载的更快！","categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://xpleeandroid.github.io/tags/android/"},{"name":"翻译","slug":"翻译","permalink":"http://xpleeandroid.github.io/tags/翻译/"}],"keywords":[]},{"title":"GoodNight","slug":"GoodNight","date":"2016-06-25T15:50:44.000Z","updated":"2016-06-28T05:42:00.662Z","comments":true,"path":"2016/06/25/GoodNight/","link":"","permalink":"http://xpleeandroid.github.io/2016/06/25/GoodNight/","excerpt":"","text":"use one day for establish this blog,thanks for opensource! Now we can say good night! ``","categories":[],"tags":[{"name":"随想","slug":"随想","permalink":"http://xpleeandroid.github.io/tags/随想/"}],"keywords":[]}]}