<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>李晓鹏</title>
  <subtitle>Adam</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xpleeandroid.github.io/"/>
  <updated>2016-09-29T05:03:30.163Z</updated>
  <id>http://xpleeandroid.github.io/</id>
  
  <author>
    <name>Adam</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Life Record of My 撒欢</title>
    <link href="http://xpleeandroid.github.io/2016/08/31/MyGoldRetriever/"/>
    <id>http://xpleeandroid.github.io/2016/08/31/MyGoldRetriever/</id>
    <published>2016-08-31T05:42:32.000Z</published>
    <updated>2016-09-29T05:03:30.163Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;2016.08.31&lt;/strong&gt;&lt;br&gt;大清早的，随地大小便了。&lt;br&gt;&lt;img src=&quot;https://xpleeandroid.github.io/img/IMG20160831084548.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;你身后是啥，不要瞪着你无辜的小眼睛看着我！&lt;br&gt;早上下楼听到他在家里叫唤了&lt;br&gt;上班路遇大撒欢三个月的金毛狗狗，三个月后撒欢长啥样？&lt;br&gt;&lt;img src=&quot;https://xpleeandroid.github.io/img/IMG_20160831_092113557.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;2016-09&quot;&gt;&lt;a href=&quot;#2016-09&quot; class=&quot;headerlink&quot; title=&quot;2016 09&quot;&gt;&lt;/a&gt;2016 09&lt;/h2&gt;&lt;p&gt;9.22&lt;br&gt;&lt;img src=&quot;https://xpleeandroid.github.io/img/sahuan/16092200.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;9.23&lt;br&gt;&lt;img src=&quot;https://xpleeandroid.github.io/img/sahuan/16092301.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://xpleeandroid.github.io/img/sahuan/16092302.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://xpleeandroid.github.io/img/sahuan/16092303.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://xpleeandroid.github.io/img/sahuan/16092304.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://xpleeandroid.github.io/img/sahuan/16092305.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;9.24&lt;br&gt;&lt;img src=&quot;https://xpleeandroid.github.io/img/sahuan/16092401.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;2016.08.31&lt;/strong&gt;&lt;br&gt;大清早的，随地大小便了。&lt;br&gt;&lt;img src=&quot;https://xpleeandroid.github.io/img/IMG20160831084548.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;你身后是啥，不要瞪着你
    
    </summary>
    
    
      <category term="撒欢" scheme="http://xpleeandroid.github.io/tags/%E6%92%92%E6%AC%A2/"/>
    
  </entry>
  
  <entry>
    <title>SS用户说明</title>
    <link href="http://xpleeandroid.github.io/2016/08/12/ss-user-guide/"/>
    <id>http://xpleeandroid.github.io/2016/08/12/ss-user-guide/</id>
    <published>2016-08-12T06:54:55.000Z</published>
    <updated>2016-09-29T04:42:41.538Z</updated>
    
    <content type="html">&lt;h1 id=&quot;ShadowSocks使用说明&quot;&gt;&lt;a href=&quot;#ShadowSocks使用说明&quot; class=&quot;headerlink&quot; title=&quot;ShadowSocks使用说明&quot;&gt;&lt;/a&gt;ShadowSocks使用说明&lt;/h1&gt;&lt;p&gt;shadowsocks是一款开源的基于UDP转发的开源的科学上网工具&lt;/p&gt;
&lt;h2 id=&quot;客户端下载与配置&quot;&gt;&lt;a href=&quot;#客户端下载与配置&quot; class=&quot;headerlink&quot; title=&quot;客户端下载与配置&quot;&gt;&lt;/a&gt;客户端下载与配置&lt;/h2&gt;&lt;p&gt;下载地址: &lt;a href=&quot;http://download.lixiaopeng.top&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://download.lixiaopeng.top&lt;/a&gt;&lt;br&gt;提供了Windows,Mac OS X  ,Android,IOS的客户端&lt;br&gt;以下显示Windows客户端的配置方法  &lt;/p&gt;
&lt;h3 id=&quot;1-下载Windows客户端&quot;&gt;&lt;a href=&quot;#1-下载Windows客户端&quot; class=&quot;headerlink&quot; title=&quot;1.下载Windows客户端&quot;&gt;&lt;/a&gt;1.下载Windows客户端&lt;/h3&gt;&lt;p&gt;下载地址  &lt;a href=&quot;http://download.lixiaopeng.top/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://download.lixiaopeng.top/&lt;/a&gt;  &lt;/p&gt;
&lt;h3 id=&quot;2-登录http-ss-lixiaopeng-top-quot-用户中心-quot-并获取配置信息&quot;&gt;&lt;a href=&quot;#2-登录http-ss-lixiaopeng-top-quot-用户中心-quot-并获取配置信息&quot; class=&quot;headerlink&quot; title=&quot;2.登录http://ss.lixiaopeng.top&amp;quot;用户中心&amp;quot;并获取配置信息&quot;&gt;&lt;/a&gt;2.登录&lt;a href=&quot;http://ss.lixiaopeng.top&amp;quot;用户中心&amp;quot;并获取配置信息&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://ss.lixiaopeng.top&amp;quot;用户中心&amp;quot;并获取配置信息&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://xpleeandroid.github.io/img/ss-1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://xpleeandroid.github.io/img/ss-2.png&quot; alt=&quot;&quot;&gt;  &lt;/p&gt;
&lt;p&gt;“server”:”xx.xxx.xxx.xx”, 服务器IP&lt;br&gt;“server_port”:xxx, 服务器端口&lt;br&gt;“local_port”:1080, 本地端口&lt;br&gt;“password”:”xxxx”, 密码&lt;br&gt;“timeout”:600, 这个不用管&lt;br&gt;“method”:”rc4-md5” 加密方式选择一样  &lt;/p&gt;
&lt;h3 id=&quot;3-双击开客户端软件并配置服务器【一般配置图片里的前4项保存即可】&quot;&gt;&lt;a href=&quot;#3-双击开客户端软件并配置服务器【一般配置图片里的前4项保存即可】&quot; class=&quot;headerlink&quot; title=&quot;3. 双击开客户端软件并配置服务器【一般配置图片里的前4项保存即可】&quot;&gt;&lt;/a&gt;3. 双击开客户端软件并配置服务器【一般配置图片里的前4项保存即可】&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://xpleeandroid.github.io/img/ss-3.png&quot; alt=&quot;&quot;&gt;  &lt;/p&gt;
&lt;h3 id=&quot;4-右击客户端如下图设置代理模式并启用代理&quot;&gt;&lt;a href=&quot;#4-右击客户端如下图设置代理模式并启用代理&quot; class=&quot;headerlink&quot; title=&quot;4. 右击客户端如下图设置代理模式并启用代理&quot;&gt;&lt;/a&gt;4. 右击客户端如下图设置代理模式并启用代理&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://xpleeandroid.github.io/img/ss-4.png&quot; alt=&quot;&quot;&gt;  &lt;/p&gt;
&lt;h3 id=&quot;此时即可用浏览器上youtube推特等国外网站&quot;&gt;&lt;a href=&quot;#此时即可用浏览器上youtube推特等国外网站&quot; class=&quot;headerlink&quot; title=&quot;此时即可用浏览器上youtube推特等国外网站&quot;&gt;&lt;/a&gt;此时即可用浏览器上youtube推特等国外网站&lt;/h3&gt;</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ShadowSocks使用说明&quot;&gt;&lt;a href=&quot;#ShadowSocks使用说明&quot; class=&quot;headerlink&quot; title=&quot;ShadowSocks使用说明&quot;&gt;&lt;/a&gt;ShadowSocks使用说明&lt;/h1&gt;&lt;p&gt;shadowsocks是一款开源的基
    
    </summary>
    
    
      <category term="shadowsocks" scheme="http://xpleeandroid.github.io/tags/shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>linux日常命令</title>
    <link href="http://xpleeandroid.github.io/2016/08/10/daily-linux-command/"/>
    <id>http://xpleeandroid.github.io/2016/08/10/daily-linux-command/</id>
    <published>2016-08-10T03:30:06.000Z</published>
    <updated>2016-08-10T08:20:25.126Z</updated>
    
    <content type="html">&lt;ul&gt;
&lt;li&gt;ps -aux | grep servers.py 查看servers.py后台进程 -aux 显示所有状态&lt;/li&gt;
&lt;li&gt;ps -ef | grep servers.py -e:显示所有进程，环境变量；-f:全格式 -h 不显示标题 &lt;/li&gt;
&lt;li&gt;kill -9 pid 强制杀死进程pid&lt;/li&gt;
&lt;li&gt;service iptabes stop 停止防火墙 centos7之前版本&lt;/li&gt;
&lt;li&gt;chkconfig iptables off 禁用防火墙 centos7之前版本&lt;/li&gt;
&lt;li&gt;systemctl stop firewalld.service 停止防火墙 centos7&lt;/li&gt;
&lt;li&gt;systemctl disable firewalld.service 禁用防火墙 centos7&lt;/li&gt;
&lt;li&gt;chmod -R 777 shadowsocks-rm&lt;/li&gt;
&lt;li&gt;mv ss-panel/{.,}* .; rmdir ss-panel 移动ss-panel文件夹下的内容到上级目录，并且删除ss-panel目录&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;ps -aux | grep servers.py 查看servers.py后台进程 -aux 显示所有状态&lt;/li&gt;
&lt;li&gt;ps -ef | grep servers.py -e:显示所有进程，环境变量；-f:全格式 -h 不显示标题 &lt;/li&gt;
&lt;li&gt;k
    
    </summary>
    
    
      <category term="linux" scheme="http://xpleeandroid.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>安卓中使用ThreadPoolExcutor</title>
    <link href="http://xpleeandroid.github.io/2016/07/29/using-threadpoolexcuter-in-android/"/>
    <id>http://xpleeandroid.github.io/2016/07/29/using-threadpoolexcuter-in-android/</id>
    <published>2016-07-29T02:14:02.000Z</published>
    <updated>2016-07-29T08:42:00.042Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原文链接 &lt;a href=&quot;https://medium.freecodecamp.com/threadpoolexecutor-in-android-8e9d22330ee3#.hiw1y4s2e&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://medium.freecodecamp.com/threadpoolexecutor-in-android-8e9d22330ee3#.hiw1y4s2e&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;翻译： &lt;a href=&quot;https://github.com/adamin1990&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Adamin90&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢！&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/img/using_threadpoolexcutor.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这篇文章将涉及到线程池，线程池执行程序，和他们在Android中的使用。&lt;br&gt;我们将使用很多的利用，详细的（thoroughly）介绍这些主题。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Thread-Pools-线程池&quot;&gt;&lt;a href=&quot;#Thread-Pools-线程池&quot; class=&quot;headerlink&quot; title=&quot;Thread Pools (线程池)&quot;&gt;&lt;/a&gt;Thread Pools (线程池)&lt;/h1&gt;&lt;p&gt;一个线程池管理一池的工作线程（准确的数量依赖于它的实现方式）。&lt;br&gt;一个task队列等待池中的空闲线程执行队列中的task.Task被生产者加入队列中，工作线程作为消费者，只要池中有空闲线程在等待新的后台任务，就会从task队列中消费任务。&lt;/p&gt;
&lt;h1 id=&quot;ThreadPoolExcutor&quot;&gt;&lt;a href=&quot;#ThreadPoolExcutor&quot; class=&quot;headerlink&quot; title=&quot;ThreadPoolExcutor&quot;&gt;&lt;/a&gt;ThreadPoolExcutor&lt;/h1&gt;&lt;p&gt;ThreadPoolExcutor 从线程池中的一个线程执行一个给定的task。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
int corePoolSize,
int maximumPoolSize,
long keepAliveTime,
TimeUnit unit,
BlockingQueue&amp;lt;Runnable&amp;gt; workQueue
);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参数解释：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;corePoolSize:&lt;/strong&gt; 线程池中保留线程的最小数目，最开始线程池中没有线程，但是随着task被加入队列，新线程被创建。如果有空闲的线程，但是线程的数目小于corePoolSize，就会创建新的线程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;maximumPoolSize:&lt;/strong&gt; 线程池中线程的最大值，如果线程数量超过corePoolSize,线程数量&amp;gt;=corePoolSize,那么只有队列满的时候才会创建新的工作线程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;keepAliveTime:&lt;/strong&gt; 当线程数量超过corepoolsize，非corepoolsize的空闲线程将等待一个新的task，如果在这个定义的时间参数内没有等到新的task，该线程将被终止。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;unit：&lt;/strong&gt; &lt;strong&gt;keppAliveTime&lt;/strong&gt;的时间单位&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;workQueue:&lt;/strong&gt;  task队列，持有runnable task，必须是一个&lt;a href=&quot;https://developer.android.com/reference/java/util/concurrent/BlockingQueue.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BlockingQueue&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;为什么在Android和JAVA应用程序中使用Thread-Pool-Executor&quot;&gt;&lt;a href=&quot;#为什么在Android和JAVA应用程序中使用Thread-Pool-Executor&quot; class=&quot;headerlink&quot; title=&quot;为什么在Android和JAVA应用程序中使用Thread Pool Executor?&quot;&gt;&lt;/a&gt;为什么在Android和JAVA应用程序中使用Thread Pool Executor?&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;它是一个强大的任务执行框架，支持任务添加到队列，任务取消，任务优先级。&lt;/li&gt;
&lt;li&gt;降低了线程创建的开销，它在线程池内管理一定数量的线程。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;在Android中使用ThreadPoolExcutor&quot;&gt;&lt;a href=&quot;#在Android中使用ThreadPoolExcutor&quot; class=&quot;headerlink&quot; title=&quot;在Android中使用ThreadPoolExcutor&quot;&gt;&lt;/a&gt;在Android中使用ThreadPoolExcutor&lt;/h1&gt;&lt;p&gt;首先，创建一个PriorityThreadFactory:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import android.os.Process;

import java.util.concurrent.ThreadFactory;

/**
 * Created by Adam on 2016/7/29.
 */
public class PriorityThreadFactory implements ThreadFactory {
private final int mThreadPrority;

public PriorityThreadFactory(int mThreadPrority) {
    this.mThreadPrority = mThreadPrority;
}

@Override
public Thread newThread(final Runnable r) {
    Runnable runnable = new Runnable() {
        @Override
        public void run() {
            try {
                Process.setThreadPriority(mThreadPrority);
            } catch (IllegalArgumentException e) {
                e.printStackTrace();
            } catch (SecurityException e) {
                e.printStackTrace();
            }
            r.run();
            ;

        }
    };
    return new Thread(runnable);
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建一个MainThreadExecutor:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import android.os.Handler;
import android.os.Looper;

import java.util.concurrent.Executor;

/**
 * Created by Adam on 2016/7/29.
 */
public class MainThreadExecutor implements Executor {

private final Handler handler = new Handler(Looper.getMainLooper());

@Override
public void execute(Runnable command) {

    handler.post(command);

}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建一个DefaultExecutorSupplier:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import android.os.Process;

import java.util.concurrent.Executor;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/**
 * Created by Adam on 2016/7/29.
 */
public class DefaultExecutorSupplier {
/*
    *指定线程数量
 */
public static final int NUMBER_OF_CORES = Runtime.getRuntime().availableProcessors();
/**
     * 后台任务的线程池
 */
private final ThreadPoolExecutor mForBackgroundTasks;
/**
     * 轻量后台任务的线程池
 */
private final ThreadPoolExecutor mForLightWeightBackgroundTasks;

/**
     * 主线程任务的线程池executor
 */
private final Executor mMainThreadExcutor;

private static DefaultExecutorSupplier mInstance;

/**
     * 返回DefaultExecutorSupplier的实例
 */
public static DefaultExecutorSupplier getInstance() {

    if (mInstance == null) {

        synchronized (DefaultExecutorSupplier.class) {
            mInstance = new DefaultExecutorSupplier();
        }
    }

    return mInstance;

}

private DefaultExecutorSupplier() {
    ThreadFactory backgroundPriorityThreadFactory = new PriorityThreadFactory(Process.THREAD_PRIORITY_BACKGROUND);
    mForBackgroundTasks = new ThreadPoolExecutor(
            NUMBER_OF_CORES * 2,
            NUMBER_OF_CORES * 2,
            60L,
            TimeUnit.SECONDS,
            new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(),
            backgroundPriorityThreadFactory

    );

    mForLightWeightBackgroundTasks = new ThreadPoolExecutor(
            NUMBER_OF_CORES * 2,
            NUMBER_OF_CORES * 2,
            60L,
            TimeUnit.SECONDS,
            new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(),
            backgroundPriorityThreadFactory
    );

    mMainThreadExcutor = new MainThreadExecutor();
}


/*
  * returns the thread pool executor for background task
  */
public ThreadPoolExecutor forBackgroundTasks() {
    return mForBackgroundTasks;
}

/*
    * returns the thread pool executor for light weight background task
    */
public ThreadPoolExecutor forLightWeightBackgroundTasks() {
    return mForLightWeightBackgroundTasks;
}

/*
    * returns the thread pool executor for main thread task
    */
public Executor forMainThreadTasks() {
    return mMainThreadExcutor;
}


}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;注意：不同线程池的数量依赖于你的需求&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;现在在你的代码中这样使用&quot;&gt;&lt;a href=&quot;#现在在你的代码中这样使用&quot; class=&quot;headerlink&quot; title=&quot;现在在你的代码中这样使用&quot;&gt;&lt;/a&gt;现在在你的代码中这样使用&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;    /*
    * 后台任务
    */
public void doSomeBackgroundWork() {
    DefaultExecutorSupplier.getInstance().forBackgroundTasks()
            .execute(new Runnable() {
                @Override
                public void run() {
                    // 在这里后台工作.
                }
            });
}

/*
    * 轻量后台任务
    */
public void doSomeLightWeightBackgroundWork() {
    DefaultExecutorSupplier.getInstance().forLightWeightBackgroundTasks()
            .execute(new Runnable() {
                @Override
                public void run() {
                    // 在这里做一些轻量后台工作.
                }
            });
}

/*
    * 主线程任务
    */
public void doSomeMainThreadWork() {
    DefaultExecutorSupplier.getInstance().forMainThreadTasks()
            .execute(new Runnable() {
                @Override
                public void run() {
                    // 做一些中线程工作.
                }
            });
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样，我们可以为网络任务，I/O任务，重型的后台任务和其他任务创建不同的线程池。&lt;/p&gt;
&lt;h1 id=&quot;怎样取消一个task？&quot;&gt;&lt;a href=&quot;#怎样取消一个task？&quot; class=&quot;headerlink&quot; title=&quot;怎样取消一个task？&quot;&gt;&lt;/a&gt;怎样取消一个task？&lt;/h1&gt;&lt;p&gt;为了取消一个task，你必须得到task的&lt;strong&gt;future&lt;/strong&gt;。所以，不要使用&lt;strong&gt;execute&lt;/strong&gt;，使用&lt;strong&gt;submit&lt;/strong&gt;，将返回一个future。现在future就可以用来取消task了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Future future= DefaultExecutorSupplier.getInstance().forBackgroundTasks()
           .submit(new Runnable() {
               @Override
               public void run() {

               }
           });

   future.cancel(true);
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;如何设置task的优先级？&quot;&gt;&lt;a href=&quot;#如何设置task的优先级？&quot; class=&quot;headerlink&quot; title=&quot;如何设置task的优先级？&quot;&gt;&lt;/a&gt;如何设置task的优先级？&lt;/h1&gt;&lt;p&gt;假设队列里有20个任务，线程池持有4个线程，我们根据task的优先级处理他们，因为线程池此时同时可处理4个线程。&lt;/p&gt;
&lt;p&gt;但是假设我们需要我们最后推进队列的任务最先执行，我们需要为该任务设置&lt;strong&gt;立即&lt;/strong&gt;的优先当线程从队列里拿取新任务时。&lt;/p&gt;
&lt;p&gt;为了设置任务的优先级，我们需要创建一个线程池executor。&lt;/p&gt;
&lt;p&gt;为优先级创建一个枚举类:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Created by Adam on 2016/7/29.
 */
public enum Priority {
/**
     * 注意：不要在任何情况下改变顺序，否则会使排序不准确
 */
/**
     * 最低优先级，预加载数据用
 */
LOW,
/**
     * 中优先级
 */
MEDIUM,
/**
     * 高优先级
 */
HIGH,
/**
     * 立即
 */
IMMEDIATE,
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;创建一个PriorityRunnable&quot;&gt;&lt;a href=&quot;#创建一个PriorityRunnable&quot; class=&quot;headerlink&quot; title=&quot;创建一个PriorityRunnable&quot;&gt;&lt;/a&gt;创建一个PriorityRunnable&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;public class PriorityRunnable implements Runnable {

private final Priority priority;

public PriorityRunnable(Priority priority) {
    this.priority = priority;
}

@Override
public void run() {

}
public Priority getPriority(){
    return  priority;
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建一个PriorityThreadPoolExecutor,继承自ThreadPoolExecutor.我们必须创建PriorityFutureTask,将实现Comparable&lt;priorityfuturetask&gt;接口。&lt;/priorityfuturetask&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.concurrent.BlockingQueue;
import java.util.concurrent.Callable;
import java.util.concurrent.Future;
import java.util.concurrent.FutureTask;
import java.util.concurrent.PriorityBlockingQueue;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/**
 * Created by Adam on 2016/7/29.
 */
public class PriorityThreadPoolExecutor extends ThreadPoolExecutor {
public PriorityThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, ThreadFactory threadFactory) {
    super(corePoolSize, maximumPoolSize, keepAliveTime, unit, new PriorityBlockingQueue&amp;lt;Runnable&amp;gt;(), threadFactory);
}


@Override
public Future&amp;lt;?&amp;gt; submit(Runnable task) {
    PriorityFutureTask futureTask = new PriorityFutureTask((PriorityRunnable) task);
    execute(futureTask);
    return futureTask;
}

private static final class PriorityFutureTask extends FutureTask&amp;lt;PriorityRunnable&amp;gt;
        implements Comparable&amp;lt;PriorityFutureTask&amp;gt; {

    private final PriorityRunnable priorityRunnable;

    public PriorityFutureTask(PriorityRunnable priorityRunnable) {
        super(priorityRunnable, null);
        this.priorityRunnable = priorityRunnable;
    }

    @Override
    public int compareTo(PriorityFutureTask another) {
        Priority p1 = priorityRunnable.getPriority();
        Priority p2 = another.priorityRunnable.getPriority();
        return p2.ordinal() - p1.ordinal();
    }
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;首先在DefaultExcutorSupplier,用PriorityThreadPoolExecutor代替ThreadPoolExecutor.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        ThreadFactory backgroundPriorityThreadFactory = new PriorityThreadFactory(Process.THREAD_PRIORITY_BACKGROUND);
//        mForBackgroundTasks = new ThreadPoolExecutor(
//                NUMBER_OF_CORES * 2,
//                NUMBER_OF_CORES * 2,
//                60L,
//                TimeUnit.SECONDS,
//                new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(),
//                backgroundPriorityThreadFactory
//
//        );
    mForBackgroundTasks=new PriorityThreadPoolExecutor(
            NUMBER_OF_CORES * 2,
            NUMBER_OF_CORES * 2,
            60L,
            TimeUnit.SECONDS,
            new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(),
            backgroundPriorityThreadFactory
    );
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面的例子演示了如何设置高优先级：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   public void doSomeTaskAtHighPriority(){
    DefaultExecutorSupplier.getInstance().forBackgroundTasks()
            .submit(new PriorityRunnable(Priority.HIGH){
                @Override
                public void run() {
                    super.run();
                }
            });
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原文链接 &lt;a href=&quot;https://medium.freecodecamp.com/threadpoolexecutor-in-android-8e9d22330ee3#.hiw1y4s2e&quot;&gt;https://medium.freecodecamp.com/threadpoolexecutor-in-android-8e9d22330ee3#.hiw1y4s2e&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;翻译： &lt;a href=&quot;https://github.com/adamin1990&quot;&gt;Adamin90&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢！&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/img/using_threadpoolexcutor.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这篇文章将涉及到线程池，线程池执行程序，和他们在Android中的使用。&lt;br&gt;我们将使用很多的利用，详细的（thoroughly）介绍这些主题。&lt;br&gt;
    
    </summary>
    
    
      <category term="android" scheme="http://xpleeandroid.github.io/tags/android/"/>
    
      <category term="翻译" scheme="http://xpleeandroid.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>安卓计算下载速度</title>
    <link href="http://xpleeandroid.github.io/2016/07/28/android-calculate-download-speed/"/>
    <id>http://xpleeandroid.github.io/2016/07/28/android-calculate-download-speed/</id>
    <published>2016-07-28T03:23:13.000Z</published>
    <updated>2016-07-28T03:41:16.658Z</updated>
    
    <content type="html">&lt;p&gt;昨天开始封装一个安卓多线程下载器，在写的过程中，猜测想加入检测下载过程中的速度，于是google一番，得出一个比较靠谱的答案，在此总结一下。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;NANOSECONDS&quot;&gt;&lt;a href=&quot;#NANOSECONDS&quot; class=&quot;headerlink&quot; title=&quot;NANOSECONDS&quot;&gt;&lt;/a&gt;NANOSECONDS&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;NANOSECONDS&lt;/strong&gt;，毫微秒，十亿分之一秒，1s=1000000000毫微秒。&lt;/p&gt;
&lt;h1 id=&quot;CODE-EXAMPLE&quot;&gt;&lt;a href=&quot;#CODE-EXAMPLE&quot; class=&quot;headerlink&quot; title=&quot;CODE EXAMPLE&quot;&gt;&lt;/a&gt;CODE EXAMPLE&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;       long start = System.nanoTime();   //开始时间
            long totalRead = 0;  //总共下载了多少
            final double NANOS_PER_SECOND = 1000000000.0;  //1秒=10亿nanoseconds
            final double BYTES_PER_MIB = 1024 * 1024;    //1M=1024*1024byte
            while (((len = is.read(buffler, 0, 1024)) &amp;gt;0)) {
                totalRead += len;
                double speed = NANOS_PER_SECOND / BYTES_PER_MIB * totalRead / (System.nanoTime() - start + 1);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;WARNING&quot;&gt;&lt;a href=&quot;#WARNING&quot; class=&quot;headerlink&quot; title=&quot;WARNING&quot;&gt;&lt;/a&gt;WARNING&lt;/h1&gt;&lt;p&gt;这种方法计算的是从start开始时间的平均速度，不是实时速度。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;昨天开始封装一个安卓多线程下载器，在写的过程中，猜测想加入检测下载过程中的速度，于是google一番，得出一个比较靠谱的答案，在此总结一下。&lt;br&gt;
    
    </summary>
    
    
      <category term="android" scheme="http://xpleeandroid.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android拍照上传至PHP服务器并写入MySql数据库(下)</title>
    <link href="http://xpleeandroid.github.io/2016/07/22/android-upload-img-to-php-server-2/"/>
    <id>http://xpleeandroid.github.io/2016/07/22/android-upload-img-to-php-server-2/</id>
    <published>2016-07-22T07:45:32.000Z</published>
    <updated>2016-07-22T08:02:25.418Z</updated>
    
    <content type="html">&lt;h1 id=&quot;Android实现&quot;&gt;&lt;a href=&quot;#Android实现&quot; class=&quot;headerlink&quot; title=&quot;Android实现&quot;&gt;&lt;/a&gt;Android实现&lt;/h1&gt;&lt;p&gt;调用系统相机，拍照：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
            getFileUri();
            intent.putExtra(MediaStore.EXTRA_OUTPUT, file_uri);
            startActivityForResult(intent, CODE_CAMERA);


  private void getFileUri() {
    image_name = Calendar.getInstance().getTimeInMillis() + &amp;quot;.jpg&amp;quot;;
    file = new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES) + File.separator + image_name);
    file_uri = Uri.fromFile(file);
}
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;在onActivityResult里面接收图片并Base64处理：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  @Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {

    if (requestCode == CODE_CAMERA &amp;amp;&amp;amp; resultCode == RESULT_OK) {
        new EncodeImage().execute();   //把bitmap转换成base64字符串
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;EncodeImage是一个AsyncTask，doInBackground里面从uri里面获取bitmap，然后转入输出流，最终转换为base64编码字符串：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
  protected Void doInBackground(Void... voids) {
      bitmap = BitmapFactory.decodeFile(file_uri.getPath());
      ByteArrayOutputStream stream = new ByteArrayOutputStream();
      bitmap.compress(Bitmap.CompressFormat.JPEG, 80, stream);
      byte[] array = stream.toByteArray();
      encoded_string = Base64.encodeToString(array, 0);
      bitmap.recycle();  //防止oom
      return null;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后就可以上传到服务器了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    private void uploadImage() {
    HashMap&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
    map.put(&amp;quot;encoding_string&amp;quot;, encoded_string);
    map.put(&amp;quot;image_name&amp;quot;, image_name);
    OkHttpUtils.post()
            .url(&amp;quot;http:192.168.0.112/phpdemo/uploadimage.php&amp;quot;)
            .params(map)
            .tag(this)
            .build()
            .execute(new StringCallback() {
                @Override
                public void onError(Call call, Exception e, int id) {
                    Log.e(&amp;quot;出错了&amp;quot;, &amp;quot;错误信息：&amp;quot; + e.getMessage());
                }

                @Override
                public void onResponse(String response, int id) {
                    Log.e(&amp;quot;成功or失败&amp;quot;, &amp;quot;信息：&amp;quot; + response);
                }
            });
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在上传服务器过程中，遇到两个问题，第一,提示&lt;code&gt;POST Content-Length of  ... bytes exceeds the limit of 8388608 bytes&lt;/code&gt;,这个错误是因为php默认最大post上传8M,更改php.ini里面的&lt;code&gt;post_max_size=1000M&lt;/code&gt;就ok了；第二，当第二次拍照的时候会出现OOM的情况，检查代码发现bitmap没有recycle。&lt;/p&gt;
&lt;p&gt;OVER&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android实现&quot;&gt;&lt;a href=&quot;#Android实现&quot; class=&quot;headerlink&quot; title=&quot;Android实现&quot;&gt;&lt;/a&gt;Android实现&lt;/h1&gt;&lt;p&gt;调用系统相机，拍照：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
            getFileUri();
            intent.putExtra(MediaStore.EXTRA_OUTPUT, file_uri);
            startActivityForResult(intent, CODE_CAMERA);


  private void getFileUri() {
    image_name = Calendar.getInstance().getTimeInMillis() + &amp;quot;.jpg&amp;quot;;
    file = new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES) + File.separator + image_name);
    file_uri = Uri.fromFile(file);
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="PHP" scheme="http://xpleeandroid.github.io/tags/PHP/"/>
    
      <category term="Android" scheme="http://xpleeandroid.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android拍照上传至PHP服务器并写入MySql数据库(上)</title>
    <link href="http://xpleeandroid.github.io/2016/07/21/android-upload-img-to-php-server-1/"/>
    <id>http://xpleeandroid.github.io/2016/07/21/android-upload-img-to-php-server-1/</id>
    <published>2016-07-21T08:45:00.000Z</published>
    <updated>2016-07-22T07:47:25.904Z</updated>
    
    <content type="html">&lt;h1 id=&quot;需求分析&quot;&gt;&lt;a href=&quot;#需求分析&quot; class=&quot;headerlink&quot; title=&quot;需求分析&quot;&gt;&lt;/a&gt;需求分析&lt;/h1&gt;&lt;p&gt;需求很简单，Android客户端点击拍照后，进行Base64加密，自动上传至服务器，服务器接收上传的数据并解密后保存到指定文件夹下，并将图片信心写入数据库，并返回相应的Json数据。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;数据库&quot;&gt;&lt;a href=&quot;#数据库&quot; class=&quot;headerlink&quot; title=&quot;数据库&quot;&gt;&lt;/a&gt;数据库&lt;/h1&gt;&lt;h2 id=&quot;创建数据库&quot;&gt;&lt;a href=&quot;#创建数据库&quot; class=&quot;headerlink&quot; title=&quot;创建数据库&quot;&gt;&lt;/a&gt;创建数据库&lt;/h2&gt;&lt;p&gt;数据库名称为 turtorial_upload_image:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE DATABASE tutorial_upload_image;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;创建表&quot;&gt;&lt;a href=&quot;#创建表&quot; class=&quot;headerlink&quot; title=&quot;创建表&quot;&gt;&lt;/a&gt;创建表&lt;/h2&gt;&lt;p&gt;我们要保存的信息是图片的名称和图片的路径，表名称是photos：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE photos(
id INT(32) NOT NULL AUTO_INCREMENT,
name VARCHAR(30) NOT NULL,
path VARCHAR(30) NOT NULL,

PRIMARY KEY(id)
);
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;PHP&quot;&gt;&lt;a href=&quot;#PHP&quot; class=&quot;headerlink&quot; title=&quot;PHP&quot;&gt;&lt;/a&gt;PHP&lt;/h1&gt;&lt;p&gt;先上代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
/**
 * Created by PhpStorm.
 * User: Adam
 * Date: 2016/7/21
 * Time: 15:01
 */
header(&amp;apos;Content-type ： bitmap; charset=utf-8;&amp;apos;);
$dbms = &amp;apos;mysql&amp;apos;;     //数据库类型

$host = &amp;apos;localhost&amp;apos;; //数据库主机名

$dbName = &amp;apos;tutorial_upload_image&amp;apos;;    //使用的数据库

$user = &amp;apos;root&amp;apos;;      //数据库连接用户名

$pass = &amp;apos;&amp;apos;;          //对应的密码

$dsn = &amp;quot;$dbms:host=$host;dbname=$dbName&amp;quot;;

if (isset($_POST[&amp;quot;encoding_string&amp;quot;])) {
$encoding_string = $_POST[&amp;quot;encoding_string&amp;quot;];

$image_name = $_POST[&amp;quot;image_name&amp;quot;];

//decode 客户端上传的base64数据
$decoded_string = base64_decode($encoding_string);

$path = &amp;quot;images/&amp;quot; . $image_name;  //定义存放路径
$file = fopen($path, &amp;quot;wb&amp;quot;);

$is_written = fwrite($file, $decoded_string);
fclose($file);
//写入数据库
if ($is_written &amp;gt; 0) {
    //sql语句
    $strSql = &amp;quot;insert into photos(name,path) values(&amp;apos;$image_name&amp;apos;,&amp;apos;$path&amp;apos;)&amp;quot;;


    //方法一 pdo方式  支持多种数据库
    try {

        $dbh = new PDO($dsn, $user, $pass); //初始化一个PDO对象
        $temp = $dbh-&amp;gt;prepare($strSql);
        $temp-&amp;gt;execute();
        $array = array(
            &amp;quot;status&amp;quot; =&amp;gt; true,
            &amp;quot;msg&amp;quot; =&amp;gt; &amp;quot;插入数据成功&amp;quot;
        );
        echo json_encode($array);
        $dbh = null; //运行完成后关闭链接
    } catch (PDOException $e) {
        $array = array(
            &amp;quot;status&amp;quot; =&amp;gt; false,
            &amp;quot;msg&amp;quot; =&amp;gt; &amp;quot;插入数据失败&amp;quot; . ($e-&amp;gt;getMessage())
        );
        echo json_encode($array);

    }


    //方法2  mysqli方式
//        $connection=mysqli_connect(&amp;apos;localhost&amp;apos;,&amp;apos;root&amp;apos;,&amp;apos;&amp;apos;,&amp;apos;tutorial_upload_image&amp;apos;);
//        $result=mysqli_query($connection,$strSql);
//        if($result){
//            $array = array (
//                &amp;quot;status&amp;quot; =&amp;gt; true,
//                &amp;quot;msg&amp;quot; =&amp;gt; &amp;quot;插入数据成功&amp;quot;
//            );
//            echo json_encode($array);
//        }else{
//            $array = array (
//                &amp;quot;status&amp;quot; =&amp;gt; false,
//                &amp;quot;msg&amp;quot; =&amp;gt; &amp;quot;插入数据失败&amp;quot;
//            );
//            echo json_encode($array);
//        }
//        mysqli_close($connection);   //关闭连接
}

}
?&amp;gt;    
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里我列举了两种连接数据库的方式 PDO和mysqli  ，mysql方式官方已经不推荐使用了，所以就不再列举（我也没用过）。数据库连接过程首先是读取POST过来的内容，然后写到images目录下面，再把地址和名称写入数据库里，返回相应的JSON数据，在这里每次上传完毕后都关闭了连接。&lt;/p&gt;
&lt;h1 id=&quot;测试&quot;&gt;&lt;a href=&quot;#测试&quot; class=&quot;headerlink&quot; title=&quot;测试&quot;&gt;&lt;/a&gt;测试&lt;/h1&gt;&lt;p&gt;测试阶段我们找用postman进行模拟发送数据，首先在&lt;a href=&quot;http://www.motobit.com/util/base64-decoder-encoder.asp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这个网站&lt;/a&gt;Base64 encode一张图片，复制之后，拷贝到postman里面，postman数据如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/android_upload_img_to_php_1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;测试结果成功~&lt;/p&gt;
&lt;p&gt;下节我们将开发安卓客户端。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;需求分析&quot;&gt;&lt;a href=&quot;#需求分析&quot; class=&quot;headerlink&quot; title=&quot;需求分析&quot;&gt;&lt;/a&gt;需求分析&lt;/h1&gt;&lt;p&gt;需求很简单，Android客户端点击拍照后，进行Base64加密，自动上传至服务器，服务器接收上传的数据并解密后保存到指定文件夹下，并将图片信心写入数据库，并返回相应的Json数据。&lt;/p&gt;
    
    </summary>
    
    
      <category term="PHP" scheme="http://xpleeandroid.github.io/tags/PHP/"/>
    
      <category term="Android" scheme="http://xpleeandroid.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>anonymous</title>
    <link href="http://xpleeandroid.github.io/2016/07/20/newsapi/"/>
    <id>http://xpleeandroid.github.io/2016/07/20/newsapi/</id>
    <published>2016-07-20T08:12:35.000Z</published>
    <updated>2016-07-20T08:16:24.973Z</updated>
    
    <content type="html">&lt;h1 id=&quot;register-host-club-qingdaonews-com&quot;&gt;&lt;a href=&quot;#register-host-club-qingdaonews-com&quot; class=&quot;headerlink&quot; title=&quot;register(host club.qingdaonews.com)&quot;&gt;&lt;/a&gt;register(host club.qingdaonews.com)&lt;/h1&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;step1  /user/touch_reg.php param: act=regstep1&amp;amp;reg_un=adamin90&amp;amp;reg_pw=wsxqaz123&amp;amp;con_pw=wsxqaz123&amp;amp;tel=15725266012  error response :{“result”:”error”,”type”:”tel”,”info”:”\u6b64\u624b\u673a\u53f7\u5df2\u7ecf\u6ce8\u518c(\u9ad8)”} success response :{“result”:”success”,”type”:”code”,”info”:”\u53d1\u9001\u6210\u529f”}&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;login-host-app-qingdaonews-com&quot;&gt;&lt;a href=&quot;#login-host-app-qingdaonews-com&quot; class=&quot;headerlink&quot; title=&quot;login (host app.qingdaonews.com)&quot;&gt;&lt;/a&gt;login (host app.qingdaonews.com)&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;/shoujikehuduan/interface_login.php?username=15725266012&amp;amp;password=wsxqaz success response :{“result”:”success”,”point”:”200”,”uid”:”8087267”,”phone”:”15725266012”,”first”:0,”token”:”52165771559e88f430573c6cd0925e68”,”money”:”0”,”face”:”http:\/\/pic.qingdaonews.com\/f\/avatar_big.jpg”,”type”:”passport”,”username”:”15725266012”,”loginname”:”15725266012”,”password”:”wsxqaz”} error response :{“result”:”error”,”point”:null,”uid”:””,”phone”:null,”first”:0,”face”:”http:\/\/pic.qingdaonews.com\/f\/avatar_big.jpg”,”type”:”passport”,”username”:”15725266019”,”loginname”:”15725266019”,”password”:”123456”}&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;签到-post-app-qingdaonews-com&quot;&gt;&lt;a href=&quot;#签到-post-app-qingdaonews-com&quot; class=&quot;headerlink&quot; title=&quot;签到 post  app.qingdaonews.com&quot;&gt;&lt;/a&gt;签到 post  app.qingdaonews.com&lt;/h1&gt;&lt;p&gt;/shoujikehuduan/interface_missionstate.php?token=52165771559e88f430573c6cd0925e68&amp;amp;mission=mis_10&lt;/p&gt;
&lt;h1 id=&quot;头条&quot;&gt;&lt;a href=&quot;#头条&quot; class=&quot;headerlink&quot; title=&quot;头条&quot;&gt;&lt;/a&gt;头条&lt;/h1&gt;&lt;p&gt;/shoujikehuduan/mdi_newslist300.php?v=2.0&amp;amp;num=20&amp;amp;type=bd&lt;/p&gt;
&lt;p&gt;/shoujikehuduan/mdi_newslist300.php?v=2.0&amp;amp;num=20&amp;amp;type=bd&amp;amp;minid=463459&lt;/p&gt;
&lt;h1 id=&quot;青青岛&quot;&gt;&lt;a href=&quot;#青青岛&quot; class=&quot;headerlink&quot; title=&quot;青青岛&quot;&gt;&lt;/a&gt;青青岛&lt;/h1&gt;&lt;p&gt;/imobile/index.php?page=1&amp;amp;title=%E5%A4%B4%E6%9D%A1&amp;amp;type=newsapp&lt;/p&gt;
&lt;h1 id=&quot;焦点&quot;&gt;&lt;a href=&quot;#焦点&quot; class=&quot;headerlink&quot; title=&quot;焦点&quot;&gt;&lt;/a&gt;焦点&lt;/h1&gt;&lt;p&gt;/shoujikehuduan/mdi_newslist300.php?v=2.0&amp;amp;num=20&amp;amp;type=jdxw&lt;/p&gt;
&lt;p&gt;/shoujikehuduan/mdi_newslist300.php?v=2.0&amp;amp;num=20&amp;amp;type=jdxw&amp;amp;minid=462981&lt;/p&gt;
&lt;h1 id=&quot;体育&quot;&gt;&lt;a href=&quot;#体育&quot; class=&quot;headerlink&quot; title=&quot;体育&quot;&gt;&lt;/a&gt;体育&lt;/h1&gt;&lt;p&gt;/shoujikehuduan/mdi_newslist300.php?v=2.0&amp;amp;num=20&amp;amp;type=ty&lt;/p&gt;
&lt;h1 id=&quot;文娱&quot;&gt;&lt;a href=&quot;#文娱&quot; class=&quot;headerlink&quot; title=&quot;文娱&quot;&gt;&lt;/a&gt;文娱&lt;/h1&gt;&lt;p&gt;yl&lt;/p&gt;
&lt;h1 id=&quot;房产&quot;&gt;&lt;a href=&quot;#房产&quot; class=&quot;headerlink&quot; title=&quot;房产&quot;&gt;&lt;/a&gt;房产&lt;/h1&gt;&lt;p&gt;qdfc&lt;/p&gt;
&lt;h1 id=&quot;汽车&quot;&gt;&lt;a href=&quot;#汽车&quot; class=&quot;headerlink&quot; title=&quot;汽车&quot;&gt;&lt;/a&gt;汽车&lt;/h1&gt;&lt;p&gt;qdqc&lt;/p&gt;
&lt;h1 id=&quot;旅游&quot;&gt;&lt;a href=&quot;#旅游&quot; class=&quot;headerlink&quot; title=&quot;旅游&quot;&gt;&lt;/a&gt;旅游&lt;/h1&gt;&lt;p&gt;qdly&lt;/p&gt;
&lt;h1 id=&quot;家居&quot;&gt;&lt;a href=&quot;#家居&quot; class=&quot;headerlink&quot; title=&quot;家居&quot;&gt;&lt;/a&gt;家居&lt;/h1&gt;&lt;p&gt;qdjj&lt;/p&gt;
&lt;h1 id=&quot;财经&quot;&gt;&lt;a href=&quot;#财经&quot; class=&quot;headerlink&quot; title=&quot;财经&quot;&gt;&lt;/a&gt;财经&lt;/h1&gt;&lt;p&gt;cj&lt;/p&gt;
&lt;h1 id=&quot;教育&quot;&gt;&lt;a href=&quot;#教育&quot; class=&quot;headerlink&quot; title=&quot;教育&quot;&gt;&lt;/a&gt;教育&lt;/h1&gt;&lt;p&gt;jy&lt;/p&gt;
&lt;h1 id=&quot;健康&quot;&gt;&lt;a href=&quot;#健康&quot; class=&quot;headerlink&quot; title=&quot;健康&quot;&gt;&lt;/a&gt;健康&lt;/h1&gt;&lt;p&gt;jk&lt;/p&gt;
&lt;h1 id=&quot;消费&quot;&gt;&lt;a href=&quot;#消费&quot; class=&quot;headerlink&quot; title=&quot;消费&quot;&gt;&lt;/a&gt;消费&lt;/h1&gt;&lt;p&gt;xf&lt;/p&gt;
&lt;h1 id=&quot;舆情&quot;&gt;&lt;a href=&quot;#舆情&quot; class=&quot;headerlink&quot; title=&quot;舆情&quot;&gt;&lt;/a&gt;舆情&lt;/h1&gt;&lt;p&gt;yuqing&lt;/p&gt;
&lt;h1 id=&quot;婚假&quot;&gt;&lt;a href=&quot;#婚假&quot; class=&quot;headerlink&quot; title=&quot;婚假&quot;&gt;&lt;/a&gt;婚假&lt;/h1&gt;&lt;p&gt;hj&lt;/p&gt;
&lt;h1 id=&quot;民生&quot;&gt;&lt;a href=&quot;#民生&quot; class=&quot;headerlink&quot; title=&quot;民生&quot;&gt;&lt;/a&gt;民生&lt;/h1&gt;&lt;p&gt;msbl&lt;/p&gt;
&lt;h1 id=&quot;黄岛-huangdao&quot;&gt;&lt;a href=&quot;#黄岛-huangdao&quot; class=&quot;headerlink&quot; title=&quot;黄岛 huangdao&quot;&gt;&lt;/a&gt;黄岛 huangdao&lt;/h1&gt;</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;register-host-club-qingdaonews-com&quot;&gt;&lt;a href=&quot;#register-host-club-qingdaonews-com&quot; class=&quot;headerlink&quot; title=&quot;register(host club.qingdaonews.com)&quot;&gt;&lt;/a&gt;register(host club.qingdaonews.com)&lt;/h1&gt;
    
    </summary>
    
    
      <category term="api" scheme="http://xpleeandroid.github.io/tags/api/"/>
    
  </entry>
  
  <entry>
    <title>English Jokes（英文笑话）</title>
    <link href="http://xpleeandroid.github.io/2016/07/07/English-Jokes/"/>
    <id>http://xpleeandroid.github.io/2016/07/07/English-Jokes/</id>
    <published>2016-07-07T06:43:44.000Z</published>
    <updated>2016-07-07T07:04:33.191Z</updated>
    
    <content type="html">&lt;h1 id=&quot;1-十个大兵与两个小偷的故事&quot;&gt;&lt;a href=&quot;#1-十个大兵与两个小偷的故事&quot; class=&quot;headerlink&quot; title=&quot;1. 十个大兵与两个小偷的故事&quot;&gt;&lt;/a&gt;1. 十个大兵与两个小偷的故事&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;Ten soldiers were setting up tents in the forest preparing for the night. 
Later, two thieves arrived and attempted to rob them of their rations, but were caught. 
The soldiers told them, &amp;quot;We would kill you, but we&amp;apos;re in a good mood today.
 We&amp;apos;ll release you if you can make us all laugh.&amp;quot; The thieves reluctantly agreed. 
One begins to tell a humorous story. 
After the story, nine of the soldiers are laughing hysterically. 
However, one is merely looking at the thief with a blank stare. 
Consequently, one soldier told the thief &amp;quot;Sorry, not all of us laughed,&amp;quot; and killed him.
The other thief was nervous after seeing his friend killed, so he told a much less entertaining story.
No soldiers were laughing except for the one who didn&amp;apos;t laugh previously, so they killed the second thief as well. 
After killing the thieves, the soldiers asked their friend, &amp;quot;Why did you laugh during the second thief&amp;apos;s story but not during the first&amp;apos;s? 
It was much funnier after all.&amp;quot; 
He responded, &amp;quot;When the second thief was speaking, I finally understood the first thief&amp;apos;s story, and it was damn funny.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;引用Zootopia（疯狂动物城）的一个场景，so hilarious!：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img4.duitang.com/uploads/item/201607/07/20160707145046_hr5LB.thumb.500_500_g.gif&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;2-狮子和森林动物的故事（给乌龟跪了）&quot;&gt;&lt;a href=&quot;#2-狮子和森林动物的故事（给乌龟跪了）&quot; class=&quot;headerlink&quot; title=&quot;2. 狮子和森林动物的故事（给乌龟跪了）&quot;&gt;&lt;/a&gt;2. 狮子和森林动物的故事（给乌龟跪了）&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;One day a lion wakes up in a bad mood and summons the other animals in the jungle. 
&amp;quot;I want each of you to tell a joke, but I warn you that if anyone of you fails to laugh, I&amp;apos;ll kill the one who told it. 
Let&amp;apos;s see, monkey, you will be first.&amp;quot; 
Shaking with fear the monkey begins, &amp;quot;Two men are in the street and...&amp;quot; 
When he finishes, everyone bursts out laughing save the tortoise. 
&amp;quot;The tortoise didn&amp;apos;t laugh!&amp;quot; roars the lion, pouncing on the monkey and ripping him to pieces. 
Then he orders, &amp;quot;Elephant, you&amp;apos;re next.&amp;quot; 
Cursing through clenched teeth, the elephant begins, &amp;quot;A drunk walks into a bar and...&amp;quot; 
When he finishes, all the animals split their sides laughing except the tortoise, who remains impassive. 
&amp;quot;The tortoise didn&amp;apos;t think it was funny!&amp;quot; exclaimed the lion who, seeing that the furious elephant is about to step on the tortoise, kills the elephant with his claws. 
By now, everyone wants to murder the tortoise, but nobody dares move. 
&amp;quot;Now it&amp;apos;s your turn, tiger,&amp;quot; orders the lion. 
The scared tiger begins, &amp;quot;They say that Little Red Riding Hood...&amp;quot; 
At that moment, the tortoise falls over laughing. &amp;quot;What&amp;apos;s with you?&amp;quot; bellows the lion. 
&amp;quot;Tiger hasn&amp;apos;t finished yet...&amp;quot; 
To which the tortoise replies, &amp;quot;The monkey&amp;apos;s joke is hilarious!&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;3-王后跟三个犯人的故事（the-queen-will-get-watermelon-shoved-up-the-third-prisoner’s-ass-hahaha-）&quot;&gt;&lt;a href=&quot;#3-王后跟三个犯人的故事（the-queen-will-get-watermelon-shoved-up-the-third-prisoner’s-ass-hahaha-）&quot; class=&quot;headerlink&quot; title=&quot;3. 王后跟三个犯人的故事（the queen will get watermelon shoved up the third prisoner’s ass? hahaha!）&quot;&gt;&lt;/a&gt;3. 王后跟三个犯人的故事（the queen will get watermelon shoved up the third prisoner’s ass? hahaha!）&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;Three prisoners on death row are summoned by the queen for a chance to be free. 
The queen tells the prisoners they have one day to go into the jungle and bring her a fruit. 
If she likes it, they are free to go. 
However, if she doesn&amp;apos;t like it, the fruit of their will be shoved up their ass, and then killed they will be back on death row. 
The first one comes back with grapes. 
The queen does not like the grapes and while the grapes were being shoved up his ass, the prisoner was crying. 
The second prisoner returns with an apple. 
Again, the queen does not like the apple and the apple gets shoved up the second prisoner&amp;apos;s ass. 
However, the first prisoner noticed that he was laughing while the apple was being inserted. 
When asked why he was crying, the second prisoner said &amp;quot;I saw the third prisoner coming back with a watermelon.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-十个大兵与两个小偷的故事&quot;&gt;&lt;a href=&quot;#1-十个大兵与两个小偷的故事&quot; class=&quot;headerlink&quot; title=&quot;1. 十个大兵与两个小偷的故事&quot;&gt;&lt;/a&gt;1. 十个大兵与两个小偷的故事&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;Ten soldiers were setting up tents in the forest preparing for the night. 
Later, two thieves arrived and attempted to rob them of their rations, but were caught. 
The soldiers told them, &amp;quot;We would kill you, but we&amp;apos;re in a good mood today.
 We&amp;apos;ll release you if you can make us all laugh.&amp;quot; The thieves reluctantly agreed. 
One begins to tell a humorous story. 
After the story, nine of the soldiers are laughing hysterically. 
However, one is merely looking at the thief with a blank stare. 
Consequently, one soldier told the thief &amp;quot;Sorry, not all of us laughed,&amp;quot; and killed him.
The other thief was nervous after seeing his friend killed, so he told a much less entertaining story.
No soldiers were laughing except for the one who didn&amp;apos;t laugh previously, so they killed the second thief as well. 
After killing the thieves, the soldiers asked their friend, &amp;quot;Why did you laugh during the second thief&amp;apos;s story but not during the first&amp;apos;s? 
It was much funnier after all.&amp;quot; 
He responded, &amp;quot;When the second thief was speaking, I finally understood the first thief&amp;apos;s story, and it was damn funny.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;引用Zootopia（疯狂动物城）的一个场景，so hilarious!：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img4.duitang.com/uploads/item/201607/07/20160707145046_hr5LB.thumb.500_500_g.gif&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="娱乐" scheme="http://xpleeandroid.github.io/tags/%E5%A8%B1%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>PHP学习笔记</title>
    <link href="http://xpleeandroid.github.io/2016/07/07/Learn-PHP/"/>
    <id>http://xpleeandroid.github.io/2016/07/07/Learn-PHP/</id>
    <published>2016-07-07T03:33:29.000Z</published>
    <updated>2016-07-08T09:51:53.028Z</updated>
    
    <content type="html">&lt;h2 id=&quot;php文件操作的模式&quot;&gt;&lt;a href=&quot;#php文件操作的模式&quot; class=&quot;headerlink&quot; title=&quot;php文件操作的模式&quot;&gt;&lt;/a&gt;php文件操作的模式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;r&lt;/strong&gt; 只读权限打开文件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;w&lt;/strong&gt; 只写权限打开文件，擦除内容，如果没有则新建文件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;a&lt;/strong&gt; 只写权限打开文件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;x&lt;/strong&gt; 新建一个只写权限的文件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;r+&lt;/strong&gt; 打开读/写权限文件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;w+&lt;/strong&gt; 打开读/写权限的文件， 擦除内容，如果没有则新建文件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;a+&lt;/strong&gt; 打开读/写权限文件，如果没有则新建文件；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;x+&lt;/strong&gt; 新建一个读/写权限的文件&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;将表单提交到本身页面&quot;&gt;&lt;a href=&quot;#将表单提交到本身页面&quot; class=&quot;headerlink&quot; title=&quot;将表单提交到本身页面&quot;&gt;&lt;/a&gt;将表单提交到本身页面&lt;/h2&gt;&lt;p&gt;只需将form的action 设置为&lt;code&gt;&amp;lt;?php echo $_SERVER[&amp;#39;PHP_SELF&amp;#39;];?&amp;gt;&lt;/code&gt;&lt;br&gt;为了防止跨站点攻击(XSS)，我们通常需要使用&lt;strong&gt;htmlspecialchars()&lt;/strong&gt;&lt;br&gt;避免&lt;strong&gt;$_SERVER[“PHP_SELF”]&lt;/strong&gt; 被利用。如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;form method=&amp;quot;post&amp;quot; action=&amp;quot;&amp;lt;?php echo htmlspecialchars($_SERVER[&amp;quot;PHP_SELF&amp;quot;]);?&amp;gt;&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;正则匹配规则&quot;&gt;&lt;a href=&quot;#正则匹配规则&quot; class=&quot;headerlink&quot; title=&quot;正则匹配规则&quot;&gt;&lt;/a&gt;正则匹配规则&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;[abc]&lt;/strong&gt;  单独的字符串 ：a,b或c&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[^abc]&lt;/strong&gt; 任意的单独字符串单不是a,b,或c&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[a-z]&lt;/strong&gt;  a-z任意的单独字符串&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[a-zA-Z]&lt;/strong&gt; a-z 或A-Z中任意的单独字符串&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;^&lt;/strong&gt;  匹配整行开头 (比如 &lt;strong&gt;^\d+&lt;/strong&gt;匹配的是任意的数字开头的字符串)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;$&lt;/strong&gt;   匹配整行结尾 (比如&lt;strong&gt;\d+$&lt;/strong&gt;匹配任意以数字结尾的字符串)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;\A&lt;/strong&gt;  匹配字符串输入的开头&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;\z&lt;/strong&gt; 匹配字符串输入的结尾&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;.&lt;/strong&gt; 任意单个字符串&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;\s&lt;/strong&gt; 任意空字符串&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;\S&lt;/strong&gt;  任意非空字符串&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;\d&lt;/strong&gt; 任意数字&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;\D&lt;/strong&gt; 任意非数字&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;\w&lt;/strong&gt; 任意任何单字符（数字，字母，下滑线）、&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;\W&lt;/strong&gt; 任意非字符&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;\B&lt;/strong&gt; 匹配任意链接字符串&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;（…）&lt;/strong&gt; 捕获封闭的内容 &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;(a|b)&lt;/strong&gt; 匹配a或b&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;a?&lt;/strong&gt; 0或1个a&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;a*&lt;/strong&gt; 0或多个a&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;a+&lt;/strong&gt; 1或多个a&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;a{3}&lt;/strong&gt; 三个a&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;a{3,}&lt;/strong&gt; 3个或更多a&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;a{3,6}&lt;/strong&gt; 3到6个a&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;i&lt;/strong&gt; 忽略大小写 &lt;strong&gt;m&lt;/strong&gt; 匹配多行 &lt;strong&gt;x&lt;/strong&gt; 忽略空白&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;php文件操作的模式&quot;&gt;&lt;a href=&quot;#php文件操作的模式&quot; class=&quot;headerlink&quot; title=&quot;php文件操作的模式&quot;&gt;&lt;/a&gt;php文件操作的模式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;r&lt;/strong&gt; 只读权限打开文件&lt;/li&gt;
    
    </summary>
    
    
      <category term="PHP" scheme="http://xpleeandroid.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>java8教程-泛型（Generics）</title>
    <link href="http://xpleeandroid.github.io/2016/06/28/java8-Generics/"/>
    <id>http://xpleeandroid.github.io/2016/06/28/java8-Generics/</id>
    <published>2016-06-28T06:04:35.000Z</published>
    <updated>2016-07-20T09:34:13.862Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原文链接 [&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/generics/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://docs.oracle.com/javase/tutorial/java/generics/index.html&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;翻译： &lt;a href=&quot;https://github.com/adamin1990&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Adamin90&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢！&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;泛型（已更新）&quot;&gt;&lt;a href=&quot;#泛型（已更新）&quot; class=&quot;headerlink&quot; title=&quot;泛型（已更新）&quot;&gt;&lt;/a&gt;泛型（已更新）&lt;/h1&gt;&lt;p&gt; 在任何繁琐的（nontrivial）软件项目中，bug是家常便饭。细心的规划，编程和测试可以帮助减少bug的普遍性（pervasiveness）,但是无论如何，无论在哪里，bug总会伺机悄悄溜进（creep）你的代码，因为很明显，新的特性会不断的被引入，并且你的代码基数会不断变大和复杂。&lt;/p&gt;
&lt;p&gt;  幸运的是，一些bug相比其它比较容易检测。编译时bug可以在早期被检测到；你可以利用编译器的错误信息查明是什么问题并且解决，就在那时。然而，运行时bug会更加未预知,他们不会立即展示出来，不知道什么时候发生，可能根本不在程序真正出现问题的点上。&lt;/p&gt;
&lt;p&gt;泛型通过更多的在编译时检测bug为你的代码增加了稳定性。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;为什么要用泛型&quot;&gt;&lt;a href=&quot;#为什么要用泛型&quot; class=&quot;headerlink&quot; title=&quot;为什么要用泛型&quot;&gt;&lt;/a&gt;为什么要用泛型&lt;/h1&gt;&lt;p&gt;简言之，泛型能够使&lt;strong&gt;类型&lt;/strong&gt;（类和接口）在定义类，接口和方法的时候参数化。非常像方法定义时用到的&lt;strong&gt;形式参数&lt;/strong&gt;（formal parameters）,类型参数提供了一种你可以通过不同的输入来复用同一段代码的方法。不同点是，&lt;strong&gt;形式参数&lt;/strong&gt;输入的是&lt;strong&gt;值&lt;/strong&gt;，而类型参数输入的是&lt;strong&gt;类型&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;使用泛型比非泛型有很多好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编译时更强大的类型检测&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; Java编译器对泛型应用了强大的类型检测，如果代码违反了类型安全就会报错。修复编译时错误比修复运行时错误更加容易，因为运行时错误很难查找到。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;消除类型转换(Elimination of casts)&lt;/p&gt;
&lt;p&gt;以下代码片段没有泛型需要转型：&lt;/p&gt;
&lt;p&gt;  List list = new ArrayList();&lt;br&gt;  list.add(“hello”);&lt;br&gt;  String s = (String) list.get(0);&lt;br&gt;当我们重新用泛型编写，代码就不需要类型转换了：&lt;/p&gt;
&lt;p&gt;  List&lt;string&gt; list = new ArrayList&lt;string&gt;();&lt;br&gt;  list.add(“hello”);&lt;br&gt;  String s = list.get(0);   // no cast&lt;/string&gt;&lt;/string&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使开发者实现泛型算法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过泛型，开发者可以自己实现泛型算法，应用到一系列的不同类型，可以自定义，并且类型安全，易读。&lt;/p&gt;
&lt;h1 id=&quot;泛型类型&quot;&gt;&lt;a href=&quot;#泛型类型&quot; class=&quot;headerlink&quot; title=&quot;泛型类型&quot;&gt;&lt;/a&gt;泛型类型&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;泛型类型&lt;/strong&gt;是泛型类或者接口被类型参数化。下面的&lt;strong&gt;Box&lt;/strong&gt;类将被更改演示这个概念。&lt;/p&gt;
&lt;h3 id=&quot;简单的-Box-类&quot;&gt;&lt;a href=&quot;#简单的-Box-类&quot; class=&quot;headerlink&quot; title=&quot;简单的 Box 类&quot;&gt;&lt;/a&gt;简单的 Box 类&lt;/h3&gt;&lt;p&gt;列举一个简单的非泛型 &lt;strong&gt;Box&lt;/strong&gt;操作任意类型的object。它只需要提供两个方法：set，添加一个obejct到box，get,获取这个对象：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Box {
private Object object;

public void set(Object object) { this.object = object; }
public Object get() { return object; }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为它的方法接收或返回一个对象，你可以任意传入，只要传入的不是原始数据类型。我们没有在编译时辨别clas如何使用的。一边可能替换一个 Integer到box，另一边获取的不是Integer类型，而可能传入一个String类型，结果会导致运行时错误。&lt;/p&gt;
&lt;h3 id=&quot;泛型版本的Box&quot;&gt;&lt;a href=&quot;#泛型版本的Box&quot; class=&quot;headerlink&quot; title=&quot;泛型版本的Box&quot;&gt;&lt;/a&gt;泛型版本的Box&lt;/h3&gt;&lt;p&gt;泛型类的定义形式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class name&amp;lt;T1, T2, ..., Tn&amp;gt; { /* ... */ }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;类型参数部分被一对尖括号（&amp;lt;&amp;gt;）划分，紧跟类名，它指定了&lt;strong&gt;类型参数&lt;/strong&gt;（也叫作类型变量）T1， T2， ….,和Tn.&lt;/p&gt;
&lt;p&gt;把原Box类更新为泛型类，你要通过把“public class Box”改变为“public class Box&lt;t&gt;”创建一个类型声明。这会引入一个&lt;strong&gt;类型变量&lt;/strong&gt;, &lt;strong&gt;T&lt;/strong&gt;,你可以在类中任意地方使用。通过这个改变，Box类就变为：&lt;/t&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Generic version of the Box class.
 * @param &amp;lt;T&amp;gt; the type of the value being boxed
 */
public class Box&amp;lt;T&amp;gt; {
// T stands for &amp;quot;Type&amp;quot;
private T t;

public void set(T t) { this.t = t; }
public T get() { return t; }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你可以看到，所有&lt;strong&gt;Object&lt;/strong&gt;出现的地方都被替换为T了。一个类型变量可以指定为任意非原始类型的类型：任意的类，任意的接口，任意的数组，甚至其他的类型变量。同样的技术可以应用到创建泛型接口上。&lt;/p&gt;
&lt;h3 id=&quot;类型参数命名规则（Naming-Conventions）&quot;&gt;&lt;a href=&quot;#类型参数命名规则（Naming-Conventions）&quot; class=&quot;headerlink&quot; title=&quot;类型参数命名规则（Naming Conventions）&quot;&gt;&lt;/a&gt;类型参数命名规则（Naming Conventions）&lt;/h3&gt;&lt;p&gt;通过规则，类型参数是单独的，大写字母。这个表示鲜明区别了你已知的变量命名规则，一个好的理由是：没有这个规则，你将很难区分类型变量和原生类或接口名的区别。&lt;/p&gt;
&lt;p&gt;最普遍使用的类型参数是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;E -Element（Java Collections框架大量使用）&lt;/li&gt;
&lt;li&gt;K -Key&lt;/li&gt;
&lt;li&gt;N -Number&lt;/li&gt;
&lt;li&gt;T -Type&lt;/li&gt;
&lt;li&gt;V -Value &lt;/li&gt;
&lt;li&gt;S,U,V 等 -第二，第三，第四个类型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你可以在JAVA SE API 看到这些名字的使用。&lt;/p&gt;
&lt;h3 id=&quot;调用和实例化一个泛型类型&quot;&gt;&lt;a href=&quot;#调用和实例化一个泛型类型&quot; class=&quot;headerlink&quot; title=&quot;调用和实例化一个泛型类型&quot;&gt;&lt;/a&gt;调用和实例化一个泛型类型&lt;/h3&gt;&lt;p&gt;要在你的代码引用泛型类 Box，你必须执行 泛型类型调用，把T替换成具体的值，比如Integer： &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Box&amp;lt;Integer&amp;gt; integerBox;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你可以认为泛型类型调用跟原生方法调用大致一样，但是不是传入一个参数到方法，而是传入一个类型蚕食–这个情况下的Integer–给Box类本身。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Type Parameter&lt;/strong&gt;和&lt;strong&gt;Type Argument&lt;/strong&gt;术语（Terminology）：&lt;br&gt;很多开发者交换使用这个两个术语，但是这两个术语并不同。敲代码时，&lt;br&gt;type argument 创建一个参数化类型，因此，Foo&amp;lt; T&amp;gt;中的T是type parameter，Foo&amp;lt; String&amp;gt; f中的String是一个type argument。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就想其他的变量定义，上面的代码不会真正创建一个新的 Box对象。它只是声明，integerBox将持有一个“Box of Integer”的引用，用以读取Box&lt;integer&gt;.泛型类型的调用通常称为参数化类型。&lt;/integer&gt;&lt;/p&gt;
&lt;p&gt;为了实例化这个类，用new 关键字，把&lt;integer&gt;放在类名和括号之间。&lt;/integer&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Box&amp;lt;Integer&amp;gt; integerBox = new Box&amp;lt;Integer&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;The-Diamond&quot;&gt;&lt;a href=&quot;#The-Diamond&quot; class=&quot;headerlink&quot; title=&quot;The Diamond&quot;&gt;&lt;/a&gt;The Diamond&lt;/h3&gt;&lt;p&gt;在Java SE 7及以后版本，可以省去类型参数调用泛型类的构造函数，用一个空的类型参数（&amp;lt;&amp;gt;）,编译器可以通过上下文决定，或推测type arguments，这个尖括号非正式得叫作diamond(钻石？这么奇葩)，你可以这样创建Box&amp;lt; Integer&amp;gt;的一个实例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Box&amp;lt;Integer&amp;gt; integerBox = new Box&amp;lt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要查看更多关于diamond 符号和类型推断（inference）,请看&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/generics/genTypeInference.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;类型推断&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;多类型参数&quot;&gt;&lt;a href=&quot;#多类型参数&quot; class=&quot;headerlink&quot; title=&quot;多类型参数&quot;&gt;&lt;/a&gt;多类型参数&lt;/h3&gt;&lt;p&gt;正如前面提到的，泛型类可以有多个类型参数。比如泛型 OrderedPair 类，实现了泛型接口 Pair：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface Pair&amp;lt;K, V&amp;gt; {
public K getKey();
public V getValue();
}

public class OrderedPair&amp;lt;K, V&amp;gt; implements Pair&amp;lt;K, V&amp;gt; {

private K key;
private V value;

public OrderedPair(K key, V value) {
this.key = key;
this.value = value;
}

public K getKey()    { return key; }
public V getValue() { return value; }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面的语句创建了两个OrderedPair的实例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Pair&amp;lt;String, Integer&amp;gt; p1 = new OrderedPair&amp;lt;String, Integer&amp;gt;(&amp;quot;Even&amp;quot;, 8);
Pair&amp;lt;String, String&amp;gt;  p2 = new OrderedPair&amp;lt;String, String&amp;gt;(&amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;new OrderedPair&lt;string,integer&gt;把K实例化为String，V实例化为Integer。因此OrderedPair的参数类型分别(respectively)是String和Integer。因为&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;自动装箱&lt;/a&gt;，传入String和int到类是有效的。&lt;/string,integer&gt;&lt;/p&gt;
&lt;h3 id=&quot;参数化类型&quot;&gt;&lt;a href=&quot;#参数化类型&quot; class=&quot;headerlink&quot; title=&quot;参数化类型&quot;&gt;&lt;/a&gt;参数化类型&lt;/h3&gt;&lt;p&gt;你也可以用一个参数化的类型（ie List&amp;lt; String&amp;gt;）替换（substitute）类型参数（K ，V）,例如用OrderedPair&amp;lt; K,V&amp;gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;OrderedPair&amp;lt;String, Box&amp;lt;Integer&amp;gt;&amp;gt; p = new OrderedPair&amp;lt;&amp;gt;(&amp;quot;primes&amp;quot;, new Box&amp;lt;Integer&amp;gt;(...));
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;原类型（Raw-Types）&quot;&gt;&lt;a href=&quot;#原类型（Raw-Types）&quot; class=&quot;headerlink&quot; title=&quot;原类型（Raw Types）&quot;&gt;&lt;/a&gt;原类型（Raw Types）&lt;/h1&gt;&lt;p&gt;原类型是指泛型类或泛型接口的名字没有任何参数，比如，给出泛型类Box：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Box(T){
public void set(T t){
/* ...... */
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你可以为形参&lt;strong&gt;T&lt;/strong&gt;赋值一个真实的类型参数来创建一个参数化类型的 Box（T）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Box(Ingeter) intBox=new Box&amp;lt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果真实的类型参数被省略掉了，你就创建了一个&lt;strong&gt;原类型&lt;/strong&gt;的Box&lt;t&gt;:&lt;/t&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Box rawBox =new Box();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因此，Box是Box&lt;t&gt;的原类型。然而，非泛型类或非泛型接口没有原类型。&lt;br&gt;原类型出现在遗赠的代码里是因为大量的API类（比如&lt;strong&gt;Collections&lt;/strong&gt;类）在JDK5之前不是泛型类。当使用原类型的时候，你本质上使用的是泛型之前的表现—Box -&amp;gt;Object.为了向后兼容，赋值参数化类型给他的原类型是允许的：&lt;/t&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Box&amp;lt;String&amp;gt; stringBox=new Box&amp;lt;&amp;gt;();
Box rawBox=stringBox;    //OK
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是如果你赋值一个原类型给一个参数化的类型，你将得到警告：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Box rawBox=new Box(); //rawBox是Box&amp;lt;T&amp;gt;()的原类型
Box&amp;lt;Integer&amp;gt; intBox=rawBox;  //warning:unchecked conversion
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当你用原类型调用关联的反省类型的泛型方法时，你也会得到警告：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Box&amp;lt;String&amp;gt; stringBox=new Box&amp;lt;&amp;gt;();
Box rawBox=stringBox;
rawBox.set(8);  //waring: unchecked invocation to set(T)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;警告显示原类型绕过泛型类型检查，延迟捕获不安全代码到运行时。因此，你需要避免使用原类型。&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/generics/erasure.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;类型擦除&lt;/a&gt;部分会有更多关于Java编译器如何使用原类型的内容。&lt;/p&gt;
&lt;h2 id=&quot;Unchecked-Error-Messages&quot;&gt;&lt;a href=&quot;#Unchecked-Error-Messages&quot; class=&quot;headerlink&quot; title=&quot;Unchecked Error Messages&quot;&gt;&lt;/a&gt;Unchecked Error Messages&lt;/h2&gt;&lt;p&gt;正如上面提到的，当混合遗赠代码和泛型代码时，你可能会碰到跟下面相似的警告：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Note: Example.java uses unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这发生在当使用老的API操作原类型时，例如如下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class WarningDemo {
Box&amp;lt;Integer&amp;gt; bi;
bi=createBox();
}
static Box createBox(){
return new Box();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;‘unchecked’指的是编译器没有足够的类型信息来执行所有必要的类型检查以保证类型安全。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原文链接 [&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/generics/index.html&quot;&gt;https://docs.oracle.com/javase/tutorial/java/generics/index.html&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;翻译： &lt;a href=&quot;https://github.com/adamin1990&quot;&gt;Adamin90&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢！&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;泛型（已更新）&quot;&gt;&lt;a href=&quot;#泛型（已更新）&quot; class=&quot;headerlink&quot; title=&quot;泛型（已更新）&quot;&gt;&lt;/a&gt;泛型（已更新）&lt;/h1&gt;&lt;p&gt; 在任何繁琐的（nontrivial）软件项目中，bug是家常便饭。细心的规划，编程和测试可以帮助减少bug的普遍性（pervasiveness）,但是无论如何，无论在哪里，bug总会伺机悄悄溜进（creep）你的代码，因为很明显，新的特性会不断的被引入，并且你的代码基数会不断变大和复杂。&lt;/p&gt;
&lt;p&gt;  幸运的是，一些bug相比其它比较容易检测。编译时bug可以在早期被检测到；你可以利用编译器的错误信息查明是什么问题并且解决，就在那时。然而，运行时bug会更加未预知,他们不会立即展示出来，不知道什么时候发生，可能根本不在程序真正出现问题的点上。&lt;/p&gt;
&lt;p&gt;泛型通过更多的在编译时检测bug为你的代码增加了稳定性。&lt;br&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://xpleeandroid.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>翻译:no more findViewById</title>
    <link href="http://xpleeandroid.github.io/2016/06/26/translate-no-more-findviewbyid/"/>
    <id>http://xpleeandroid.github.io/2016/06/26/translate-no-more-findviewbyid/</id>
    <published>2016-06-26T06:40:57.000Z</published>
    <updated>2016-06-28T09:49:39.814Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原文链接 &lt;a href=&quot;https://medium.com/google-developers/no-more-findviewbyid-457457644885#.cs0jg2og6&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://medium.com/google-developers/no-more-findviewbyid-457457644885#.cs0jg2og6&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;翻译： &lt;a href=&quot;https://github.com/adamin1990&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Adamin90&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢！&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;No-More-findViewById&quot;&gt;&lt;a href=&quot;#No-More-findViewById&quot; class=&quot;headerlink&quot; title=&quot;No More findViewById&quot;&gt;&lt;/a&gt;No More findViewById&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;Android Studio开发android程序的一个小特点是数据绑定。我会在将来的文章中讲解它的其他一些优雅的特点，但是你要了解的最基础的是怎样消除findViewById.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;TextView hello = (TextView) findViewById(R.id.hello);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;虽然现在有很多试用的方法可以省略这些多余代码，但是Android Studio 1.5以及更高版本已经有官方的方法了。&lt;/p&gt;
&lt;p&gt;首先，你必须在Application的build.gradle里的android块内填写如下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;android {
…
dataBinding.enabled = true
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;下一步就是在你的layout文件的最外层添加 &lt;layout&gt;标签，不管你用的是任何 ViewGroup:&lt;/layout&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;layout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
    xmlns:tools=&amp;quot;http://schemas.android.com/tools&amp;quot;&amp;gt;
&amp;lt;RelativeLayout
        android:layout_width=&amp;quot;match_parent&amp;quot;
        android:layout_height=&amp;quot;match_parent&amp;quot;
        android:paddingLeft=&amp;quot;@dimen/activity_horizontal_margin&amp;quot;
        android:paddingRight=&amp;quot;@dimen/activity_horizontal_margin&amp;quot;
        android:paddingTop=&amp;quot;@dimen/activity_vertical_margin&amp;quot;
        android:paddingBottom=&amp;quot;@dimen/activity_vertical_margin&amp;quot;
        tools:context=&amp;quot;.MainActivity&amp;quot;&amp;gt;

    &amp;lt;TextView
            android:id=&amp;quot;@+id/hello&amp;quot;
            android:layout_width=&amp;quot;wrap_content&amp;quot;
            android:layout_height=&amp;quot;wrap_content&amp;quot;/&amp;gt;

&amp;lt;/RelativeLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Layout&lt;/strong&gt;标签告诉Android Studio这个layout在编译时将进行额外的操作，查找到所有感兴趣的view,并且标签为下一步。所有外部没有包&lt;code&gt;layout&lt;/code&gt;标签的布局将不会执行额外操作。所以你可以在新项目中少量使用而无需改变项目中其他的部分。&lt;/p&gt;
&lt;p&gt;下面要做的就是告诉它在运行时分别加载你的layout。因为它向后兼容，所以不需要依赖新框架的改变来加载这些预执行的layout文件。因此你只需对程序做一个轻微的改变。&lt;/p&gt;
&lt;p&gt;从一个Activity,不是：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;    setContentView(R.layout.hello_world);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;TextView hello = (TextView) findViewById(R.id.hello);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hello.setText(&lt;span class=&quot;string&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;); &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;而是这样加载：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HelloWorldBinding binding = 
DataBindingUtil.setContentView(this, R.layout.hello_world);
binding.hello.setText(&amp;quot;Hello World&amp;quot;); 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你可以看到 &lt;strong&gt;HelloWordBinding&lt;/strong&gt;这个类自动为&lt;strong&gt;hello_world.xml&lt;/strong&gt;生成并且id为“@+id/hello”的view分配到了一个&lt;strong&gt;hello&lt;/strong&gt;的field你可以使用。没有强制类型转换，没有findViewById.&lt;/p&gt;
&lt;p&gt;这标兵这是访问view的机制不仅仅比findViewById更加简单，而且也更加快！绑定程序一次执行覆盖所有layout的view，把view分配到field。当你运行findViewById，的时候view结构每次都会被遍历查找。&lt;/p&gt;
&lt;p&gt;你会注意到一件事:它对你的变量名使用了驼峰命名法（比如hello_world.html 变成类 HelloWorldBinding）,所以如果你给它的id是“@+id/hello_text”,那么field的名称将会是 helloText.&lt;/p&gt;
&lt;p&gt;当你正在inflate你布局里RecyclerView,ViewPager，或其他不设置Activity内容的控件，你将希望在生成的类上用生成的类型安全的方法，这里有几个版本匹配LayoutInflater,所以使用你最适合食用的.举个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HelloWorldBinding binding = HelloWorldBinding.inflate(
getLayoutInflater(), container, attachToContainer);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果你们有把被inflate的view 附加到包含他们的ViewGroup上，你必须访问被infalte的view的view结构。你可以用binding的getRoot()方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;linearLayout.addView(binding.getRoot());
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在，你可能会考虑，如果我有一个layout包含同步view的不同配置呢？layout预执行和运行时inflate阶段通过添加所有View 的id到生成的类，如果没有被inflate的话设置为null。&lt;/p&gt;
&lt;p&gt;相当神奇，不是吗？最好的部分是运行时没有反射和其他任何高消耗的技术。把他少量添加到你现有程序里面非常容易，他能让你的生活更加简单，让你的layout加载的更快！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原文链接 &lt;a href=&quot;https://medium.com/google-developers/no-more-findviewbyid-457457644885#.cs0jg2og6&quot;&gt;https://medium.com/google-developers/no-more-findviewbyid-457457644885#.cs0jg2og6&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;翻译： &lt;a href=&quot;https://github.com/adamin1990&quot;&gt;Adamin90&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢！&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;No-More-findViewById&quot;&gt;&lt;a href=&quot;#No-More-findViewById&quot; class=&quot;headerlink&quot; title=&quot;No More findViewById&quot;&gt;&lt;/a&gt;No More findViewById&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;Android Studio开发android程序的一个小特点是数据绑定。我会在将来的文章中讲解它的其他一些优雅的特点，但是你要了解的最基础的是怎样消除findViewById.&lt;br&gt;
    
    </summary>
    
    
      <category term="android" scheme="http://xpleeandroid.github.io/tags/android/"/>
    
      <category term="翻译" scheme="http://xpleeandroid.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>GoodNight</title>
    <link href="http://xpleeandroid.github.io/2016/06/25/GoodNight/"/>
    <id>http://xpleeandroid.github.io/2016/06/25/GoodNight/</id>
    <published>2016-06-25T15:50:44.000Z</published>
    <updated>2016-06-28T05:42:00.662Z</updated>
    
    <content type="html">&lt;p&gt; use one day for establish this blog,thanks for opensource!&lt;/p&gt;
&lt;p&gt; Now we can say good night!&lt;/p&gt;
&lt;p&gt; ``&lt;br&gt;&lt;img src=&quot;http://f5.topitme.com/5/98/93/1153052438ba893985l.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt; use one day for establish this blog,thanks for opensource!&lt;/p&gt;
&lt;p&gt; Now we can say good night!&lt;/p&gt;
&lt;p&gt; ``&lt;br&gt;&lt;img src=&quot;http://f5.topitme.
    
    </summary>
    
    
      <category term="随想" scheme="http://xpleeandroid.github.io/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
</feed>
